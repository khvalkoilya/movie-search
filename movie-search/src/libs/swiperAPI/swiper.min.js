/**
 * Swiper 5.3.8
 * Most modern mobile touch slider and framework with hardware accelerated transitions
 * http://swiperjs.com
 *
 * Copyright 2014-2020 Vladimir Kharlampidi
 *
 * Released under the MIT License
 *
 * Released on: April 24, 2020
 */

!(function (e, t) { typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = t() : typeof define === 'function' && define.amd ? define(t) : (e = e || self).Swiper = t(); }(this, (() => {
  const e = typeof document === 'undefined' ? {
    body: {},
    addEventListener() {},
    removeEventListener() {},
    activeElement: { blur() {}, nodeName: '' },
    querySelector() { return null; },
    querySelectorAll() { return []; },
    getElementById() { return null; },
    createEvent() { return { initEvent() {} }; },
    createElement() {
      return {
        children: [], childNodes: [], style: {}, setAttribute() {}, getElementsByTagName() { return []; },
      };
    },
    location: { hash: '' },
  } : document; const t = typeof window === 'undefined' ? {
    document: e, navigator: { userAgent: '' }, location: {}, history: {}, CustomEvent() { return this; }, addEventListener() {}, removeEventListener() {}, getComputedStyle() { return { getPropertyValue() { return ''; } }; }, Image() {}, Date() {}, screen: {}, setTimeout() {}, clearTimeout() {},
  } : window; const i = function (e) { for (let t = 0; t < e.length; t += 1) this[t] = e[t]; return this.length = e.length, this; }; function s(s, a) { const r = []; let n = 0; if (s && !a && s instanceof i) return s; if (s) if (typeof s === 'string') { let o; let l; const d = s.trim(); if (d.indexOf('<') >= 0 && d.indexOf('>') >= 0) { let h = 'div'; for (d.indexOf('<li') === 0 && (h = 'ul'), d.indexOf('<tr') === 0 && (h = 'tbody'), d.indexOf('<td') !== 0 && d.indexOf('<th') !== 0 || (h = 'tr'), d.indexOf('<tbody') === 0 && (h = 'table'), d.indexOf('<option') === 0 && (h = 'select'), (l = e.createElement(h)).innerHTML = d, n = 0; n < l.childNodes.length; n += 1)r.push(l.childNodes[n]); } else for (o = a || s[0] !== '#' || s.match(/[ .<>:~]/) ? (a || e).querySelectorAll(s.trim()) : [e.getElementById(s.trim().split('#')[1])], n = 0; n < o.length; n += 1)o[n] && r.push(o[n]); } else if (s.nodeType || s === t || s === e)r.push(s); else if (s.length > 0 && s[0].nodeType) for (n = 0; n < s.length; n += 1)r.push(s[n]); return new i(r); } function a(e) { for (var t = [], i = 0; i < e.length; i += 1)t.indexOf(e[i]) === -1 && t.push(e[i]); return t; }s.fn = i.prototype, s.Class = i, s.Dom7 = i; const r = {
    addClass(e) { if (void 0 === e) return this; for (let t = e.split(' '), i = 0; i < t.length; i += 1) for (let s = 0; s < this.length; s += 1) void 0 !== this[s] && void 0 !== this[s].classList && this[s].classList.add(t[i]); return this; }, removeClass(e) { for (let t = e.split(' '), i = 0; i < t.length; i += 1) for (let s = 0; s < this.length; s += 1) void 0 !== this[s] && void 0 !== this[s].classList && this[s].classList.remove(t[i]); return this; }, hasClass(e) { return !!this[0] && this[0].classList.contains(e); }, toggleClass(e) { for (let t = e.split(' '), i = 0; i < t.length; i += 1) for (let s = 0; s < this.length; s += 1) void 0 !== this[s] && void 0 !== this[s].classList && this[s].classList.toggle(t[i]); return this; }, attr(e, t) { const i = arguments; if (arguments.length === 1 && typeof e === 'string') return this[0] ? this[0].getAttribute(e) : void 0; for (let s = 0; s < this.length; s += 1) if (i.length === 2) this[s].setAttribute(e, t); else for (const a in e) this[s][a] = e[a], this[s].setAttribute(a, e[a]); return this; }, removeAttr(e) { for (let t = 0; t < this.length; t += 1) this[t].removeAttribute(e); return this; }, data(e, t) { let i; if (void 0 !== t) { for (let s = 0; s < this.length; s += 1)(i = this[s]).dom7ElementDataStorage || (i.dom7ElementDataStorage = {}), i.dom7ElementDataStorage[e] = t; return this; } if (i = this[0]) { if (i.dom7ElementDataStorage && e in i.dom7ElementDataStorage) return i.dom7ElementDataStorage[e]; const a = i.getAttribute(`data-${e}`); return a || void 0; } }, transform(e) { for (let t = 0; t < this.length; t += 1) { const i = this[t].style; i.webkitTransform = e, i.transform = e; } return this; }, transition(e) { typeof e !== 'string' && (e += 'ms'); for (let t = 0; t < this.length; t += 1) { const i = this[t].style; i.webkitTransitionDuration = e, i.transitionDuration = e; } return this; }, on() { for (var e, t = [], i = arguments.length; i--;)t[i] = arguments[i]; let a = t[0]; let r = t[1]; let n = t[2]; let o = t[3]; function l(e) { const t = e.target; if (t) { const i = e.target.dom7EventData || []; if (i.indexOf(e) < 0 && i.unshift(e), s(t).is(r))n.apply(t, i); else for (let a = s(t).parents(), o = 0; o < a.length; o += 1)s(a[o]).is(r) && n.apply(a[o], i); } } function d(e) { const t = e && e.target && e.target.dom7EventData || []; t.indexOf(e) < 0 && t.unshift(e), n.apply(this, t); } typeof t[1] === 'function' && (a = (e = t)[0], n = e[1], o = e[2], r = void 0), o || (o = !1); for (var h, p = a.split(' '), c = 0; c < this.length; c += 1) { const u = this[c]; if (r) for (h = 0; h < p.length; h += 1) { const v = p[h]; u.dom7LiveListeners || (u.dom7LiveListeners = {}), u.dom7LiveListeners[v] || (u.dom7LiveListeners[v] = []), u.dom7LiveListeners[v].push({ listener: n, proxyListener: l }), u.addEventListener(v, l, o); } else for (h = 0; h < p.length; h += 1) { const f = p[h]; u.dom7Listeners || (u.dom7Listeners = {}), u.dom7Listeners[f] || (u.dom7Listeners[f] = []), u.dom7Listeners[f].push({ listener: n, proxyListener: d }), u.addEventListener(f, d, o); } } return this; }, off() { for (var e, t = [], i = arguments.length; i--;)t[i] = arguments[i]; let s = t[0]; let a = t[1]; let r = t[2]; let n = t[3]; typeof t[1] === 'function' && (s = (e = t)[0], r = e[1], n = e[2], a = void 0), n || (n = !1); for (let o = s.split(' '), l = 0; l < o.length; l += 1) for (let d = o[l], h = 0; h < this.length; h += 1) { const p = this[h]; let c = void 0; if (!a && p.dom7Listeners ? c = p.dom7Listeners[d] : a && p.dom7LiveListeners && (c = p.dom7LiveListeners[d]), c && c.length) for (let u = c.length - 1; u >= 0; u -= 1) { const v = c[u]; r && v.listener === r || r && v.listener && v.listener.dom7proxy && v.listener.dom7proxy === r ? (p.removeEventListener(d, v.proxyListener, n), c.splice(u, 1)) : r || (p.removeEventListener(d, v.proxyListener, n), c.splice(u, 1)); } } return this; }, trigger() { for (var i = [], s = arguments.length; s--;)i[s] = arguments[s]; for (let a = i[0].split(' '), r = i[1], n = 0; n < a.length; n += 1) for (let o = a[n], l = 0; l < this.length; l += 1) { const d = this[l]; let h = void 0; try { h = new t.CustomEvent(o, { detail: r, bubbles: !0, cancelable: !0 }); } catch (t) { (h = e.createEvent('Event')).initEvent(o, !0, !0), h.detail = r; }d.dom7EventData = i.filter(((e, t) => t > 0)), d.dispatchEvent(h), d.dom7EventData = [], delete d.dom7EventData; } return this; }, transitionEnd(e) { let t; const i = ['webkitTransitionEnd', 'transitionend']; const s = this; function a(r) { if (r.target === this) for (e.call(this, r), t = 0; t < i.length; t += 1)s.off(i[t], a); } if (e) for (t = 0; t < i.length; t += 1)s.on(i[t], a); return this; }, outerWidth(e) { if (this.length > 0) { if (e) { const t = this.styles(); return this[0].offsetWidth + parseFloat(t.getPropertyValue('margin-right')) + parseFloat(t.getPropertyValue('margin-left')); } return this[0].offsetWidth; } return null; }, outerHeight(e) { if (this.length > 0) { if (e) { const t = this.styles(); return this[0].offsetHeight + parseFloat(t.getPropertyValue('margin-top')) + parseFloat(t.getPropertyValue('margin-bottom')); } return this[0].offsetHeight; } return null; }, offset() { if (this.length > 0) { const i = this[0]; const s = i.getBoundingClientRect(); const a = e.body; const r = i.clientTop || a.clientTop || 0; const n = i.clientLeft || a.clientLeft || 0; const o = i === t ? t.scrollY : i.scrollTop; const l = i === t ? t.scrollX : i.scrollLeft; return { top: s.top + o - r, left: s.left + l - n }; } return null; }, css(e, i) { let s; if (arguments.length === 1) { if (typeof e !== 'string') { for (s = 0; s < this.length; s += 1) for (const a in e) this[s].style[a] = e[a]; return this; } if (this[0]) return t.getComputedStyle(this[0], null).getPropertyValue(e); } if (arguments.length === 2 && typeof e === 'string') { for (s = 0; s < this.length; s += 1) this[s].style[e] = i; return this; } return this; }, each(e) { if (!e) return this; for (let t = 0; t < this.length; t += 1) if (!1 === e.call(this[t], t, this[t])) return this; return this; }, html(e) { if (void 0 === e) return this[0] ? this[0].innerHTML : void 0; for (let t = 0; t < this.length; t += 1) this[t].innerHTML = e; return this; }, text(e) { if (void 0 === e) return this[0] ? this[0].textContent.trim() : null; for (let t = 0; t < this.length; t += 1) this[t].textContent = e; return this; }, is(a) { let r; let n; const o = this[0]; if (!o || void 0 === a) return !1; if (typeof a === 'string') { if (o.matches) return o.matches(a); if (o.webkitMatchesSelector) return o.webkitMatchesSelector(a); if (o.msMatchesSelector) return o.msMatchesSelector(a); for (r = s(a), n = 0; n < r.length; n += 1) if (r[n] === o) return !0; return !1; } if (a === e) return o === e; if (a === t) return o === t; if (a.nodeType || a instanceof i) { for (r = a.nodeType ? [a] : a, n = 0; n < r.length; n += 1) if (r[n] === o) return !0; return !1; } return !1; }, index() { let e; let t = this[0]; if (t) { for (e = 0; (t = t.previousSibling) !== null;)t.nodeType === 1 && (e += 1); return e; } }, eq(e) { if (void 0 === e) return this; let t; const s = this.length; return new i(e > s - 1 ? [] : e < 0 ? (t = s + e) < 0 ? [] : [this[t]] : [this[e]]); }, append() { for (var t, s = [], a = arguments.length; a--;)s[a] = arguments[a]; for (let r = 0; r < s.length; r += 1) { t = s[r]; for (let n = 0; n < this.length; n += 1) if (typeof t === 'string') { const o = e.createElement('div'); for (o.innerHTML = t; o.firstChild;) this[n].appendChild(o.firstChild); } else if (t instanceof i) for (let l = 0; l < t.length; l += 1) this[n].appendChild(t[l]); else this[n].appendChild(t); } return this; }, prepend(t) { let s; let a; for (s = 0; s < this.length; s += 1) if (typeof t === 'string') { const r = e.createElement('div'); for (r.innerHTML = t, a = r.childNodes.length - 1; a >= 0; a -= 1) this[s].insertBefore(r.childNodes[a], this[s].childNodes[0]); } else if (t instanceof i) for (a = 0; a < t.length; a += 1) this[s].insertBefore(t[a], this[s].childNodes[0]); else this[s].insertBefore(t, this[s].childNodes[0]); return this; }, next(e) { return this.length > 0 ? e ? this[0].nextElementSibling && s(this[0].nextElementSibling).is(e) ? new i([this[0].nextElementSibling]) : new i([]) : this[0].nextElementSibling ? new i([this[0].nextElementSibling]) : new i([]) : new i([]); }, nextAll(e) { const t = []; let a = this[0]; if (!a) return new i([]); for (;a.nextElementSibling;) { const r = a.nextElementSibling; e ? s(r).is(e) && t.push(r) : t.push(r), a = r; } return new i(t); }, prev(e) { if (this.length > 0) { const t = this[0]; return e ? t.previousElementSibling && s(t.previousElementSibling).is(e) ? new i([t.previousElementSibling]) : new i([]) : t.previousElementSibling ? new i([t.previousElementSibling]) : new i([]); } return new i([]); }, prevAll(e) { const t = []; let a = this[0]; if (!a) return new i([]); for (;a.previousElementSibling;) { const r = a.previousElementSibling; e ? s(r).is(e) && t.push(r) : t.push(r), a = r; } return new i(t); }, parent(e) { for (var t = [], i = 0; i < this.length; i += 1) this[i].parentNode !== null && (e ? s(this[i].parentNode).is(e) && t.push(this[i].parentNode) : t.push(this[i].parentNode)); return s(a(t)); }, parents(e) { for (var t = [], i = 0; i < this.length; i += 1) for (let r = this[i].parentNode; r;)e ? s(r).is(e) && t.push(r) : t.push(r), r = r.parentNode; return s(a(t)); }, closest(e) { let t = this; return void 0 === e ? new i([]) : (t.is(e) || (t = t.parents(e).eq(0)), t); }, find(e) { for (var t = [], s = 0; s < this.length; s += 1) for (let a = this[s].querySelectorAll(e), r = 0; r < a.length; r += 1)t.push(a[r]); return new i(t); }, children(e) { for (var t = [], r = 0; r < this.length; r += 1) for (let n = this[r].childNodes, o = 0; o < n.length; o += 1)e ? n[o].nodeType === 1 && s(n[o]).is(e) && t.push(n[o]) : n[o].nodeType === 1 && t.push(n[o]); return new i(a(t)); }, filter(e) { for (var t = [], s = 0; s < this.length; s += 1)e.call(this[s], s, this[s]) && t.push(this[s]); return new i(t); }, remove() { for (let e = 0; e < this.length; e += 1) this[e].parentNode && this[e].parentNode.removeChild(this[e]); return this; }, add() { for (var e = [], t = arguments.length; t--;)e[t] = arguments[t]; let i; let a; const r = this; for (i = 0; i < e.length; i += 1) { const n = s(e[i]); for (a = 0; a < n.length; a += 1)r[r.length] = n[a], r.length += 1; } return r; }, styles() { return this[0] ? t.getComputedStyle(this[0], null) : {}; },
  }; Object.keys(r).forEach(((e) => { s.fn[e] = s.fn[e] || r[e]; })); var n = {
    deleteProps(e) { const t = e; Object.keys(t).forEach(((e) => { try { t[e] = null; } catch (e) {} try { delete t[e]; } catch (e) {} })); }, nextTick(e, t) { return void 0 === t && (t = 0), setTimeout(e, t); }, now() { return Date.now(); }, getTranslate(e, i) { let s; let a; let r; void 0 === i && (i = 'x'); const n = t.getComputedStyle(e, null); return t.WebKitCSSMatrix ? ((a = n.transform || n.webkitTransform).split(',').length > 6 && (a = a.split(', ').map(((e) => e.replace(',', '.'))).join(', ')), r = new t.WebKitCSSMatrix(a === 'none' ? '' : a)) : s = (r = n.MozTransform || n.OTransform || n.MsTransform || n.msTransform || n.transform || n.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,')).toString().split(','), i === 'x' && (a = t.WebKitCSSMatrix ? r.m41 : s.length === 16 ? parseFloat(s[12]) : parseFloat(s[4])), i === 'y' && (a = t.WebKitCSSMatrix ? r.m42 : s.length === 16 ? parseFloat(s[13]) : parseFloat(s[5])), a || 0; }, parseUrlQuery(e) { let i; let s; let a; let r; const n = {}; let o = e || t.location.href; if (typeof o === 'string' && o.length) for (r = (s = (o = o.indexOf('?') > -1 ? o.replace(/\S*\?/, '') : '').split('&').filter(((e) => e !== ''))).length, i = 0; i < r; i += 1)a = s[i].replace(/#\S+/g, '').split('='), n[decodeURIComponent(a[0])] = void 0 === a[1] ? void 0 : decodeURIComponent(a[1]) || ''; return n; }, isObject(e) { return typeof e === 'object' && e !== null && e.constructor && e.constructor === Object; }, extend() { for (var e = [], t = arguments.length; t--;)e[t] = arguments[t]; for (var i = Object(e[0]), s = 1; s < e.length; s += 1) { const a = e[s]; if (a != null) for (let r = Object.keys(Object(a)), o = 0, l = r.length; o < l; o += 1) { const d = r[o]; const h = Object.getOwnPropertyDescriptor(a, d); void 0 !== h && h.enumerable && (n.isObject(i[d]) && n.isObject(a[d]) ? n.extend(i[d], a[d]) : !n.isObject(i[d]) && n.isObject(a[d]) ? (i[d] = {}, n.extend(i[d], a[d])) : i[d] = a[d]); } } return i; },
  }; const o = {
    touch: t.Modernizr && !0 === t.Modernizr.touch || !!(t.navigator.maxTouchPoints > 0 || 'ontouchstart' in t || t.DocumentTouch && e instanceof t.DocumentTouch), pointerEvents: !!t.PointerEvent && 'maxTouchPoints' in t.navigator && t.navigator.maxTouchPoints > 0, observer: 'MutationObserver' in t || 'WebkitMutationObserver' in t, passiveListener: (function () { let e = !1; try { const i = Object.defineProperty({}, 'passive', { get() { e = !0; } }); t.addEventListener('testPassiveListener', null, i); } catch (e) {} return e; }()), gestures: 'ongesturestart' in t,
  }; const l = function (e) { void 0 === e && (e = {}); const t = this; t.params = e, t.eventsListeners = {}, t.params && t.params.on && Object.keys(t.params.on).forEach(((e) => { t.on(e, t.params.on[e]); })); }; const d = { components: { configurable: !0 } }; l.prototype.on = function (e, t, i) { const s = this; if (typeof t !== 'function') return s; const a = i ? 'unshift' : 'push'; return e.split(' ').forEach(((e) => { s.eventsListeners[e] || (s.eventsListeners[e] = []), s.eventsListeners[e][a](t); })), s; }, l.prototype.once = function (e, t, i) { const s = this; if (typeof t !== 'function') return s; function a() { for (var i = [], r = arguments.length; r--;)i[r] = arguments[r]; s.off(e, a), a.f7proxy && delete a.f7proxy, t.apply(s, i); } return a.f7proxy = t, s.on(e, a, i); }, l.prototype.off = function (e, t) { const i = this; return i.eventsListeners ? (e.split(' ').forEach(((e) => { void 0 === t ? i.eventsListeners[e] = [] : i.eventsListeners[e] && i.eventsListeners[e].length && i.eventsListeners[e].forEach(((s, a) => { (s === t || s.f7proxy && s.f7proxy === t) && i.eventsListeners[e].splice(a, 1); })); })), i) : i; }, l.prototype.emit = function () { for (var e = [], t = arguments.length; t--;)e[t] = arguments[t]; let i; let s; let a; const r = this; if (!r.eventsListeners) return r; typeof e[0] === 'string' || Array.isArray(e[0]) ? (i = e[0], s = e.slice(1, e.length), a = r) : (i = e[0].events, s = e[0].data, a = e[0].context || r); const n = Array.isArray(i) ? i : i.split(' '); return n.forEach(((e) => { if (r.eventsListeners && r.eventsListeners[e]) { const t = []; r.eventsListeners[e].forEach(((e) => { t.push(e); })), t.forEach(((e) => { e.apply(a, s); })); } })), r; }, l.prototype.useModulesParams = function (e) { const t = this; t.modules && Object.keys(t.modules).forEach(((i) => { const s = t.modules[i]; s.params && n.extend(e, s.params); })); }, l.prototype.useModules = function (e) { void 0 === e && (e = {}); const t = this; t.modules && Object.keys(t.modules).forEach(((i) => { const s = t.modules[i]; const a = e[i] || {}; s.instance && Object.keys(s.instance).forEach(((e) => { const i = s.instance[e]; t[e] = typeof i === 'function' ? i.bind(t) : i; })), s.on && t.on && Object.keys(s.on).forEach(((e) => { t.on(e, s.on[e]); })), s.create && s.create.bind(t)(a); })); }, d.components.set = function (e) { this.use && this.use(e); }, l.installModule = function (e) { for (var t = [], i = arguments.length - 1; i-- > 0;)t[i] = arguments[i + 1]; const s = this; s.prototype.modules || (s.prototype.modules = {}); const a = e.name || `${Object.keys(s.prototype.modules).length}_${n.now()}`; return s.prototype.modules[a] = e, e.proto && Object.keys(e.proto).forEach(((t) => { s.prototype[t] = e.proto[t]; })), e.static && Object.keys(e.static).forEach(((t) => { s[t] = e.static[t]; })), e.install && e.install.apply(s, t), s; }, l.use = function (e) { for (var t = [], i = arguments.length - 1; i-- > 0;)t[i] = arguments[i + 1]; const s = this; return Array.isArray(e) ? (e.forEach(((e) => s.installModule(e))), s) : s.installModule.apply(s, [e].concat(t)); }, Object.defineProperties(l, d); const h = {
    updateSize() { let e; let t; const i = this.$el; e = void 0 !== this.params.width ? this.params.width : i[0].clientWidth, t = void 0 !== this.params.height ? this.params.height : i[0].clientHeight, e === 0 && this.isHorizontal() || t === 0 && this.isVertical() || (e = e - parseInt(i.css('padding-left'), 10) - parseInt(i.css('padding-right'), 10), t = t - parseInt(i.css('padding-top'), 10) - parseInt(i.css('padding-bottom'), 10), n.extend(this, { width: e, height: t, size: this.isHorizontal() ? e : t })); },
    updateSlides() {
      const e = this.params; const i = this.$wrapperEl; const s = this.size; const a = this.rtlTranslate; const r = this.wrongRTL; const o = this.virtual && e.virtual.enabled; const l = o ? this.virtual.slides.length : this.slides.length; const d = i.children(`.${this.params.slideClass}`); const h = o ? this.virtual.slides.length : d.length; let p = []; const c = []; const u = []; function v(t) { return !e.cssMode || t !== d.length - 1; } let f = e.slidesOffsetBefore; typeof f === 'function' && (f = e.slidesOffsetBefore.call(this)); let m = e.slidesOffsetAfter; typeof m === 'function' && (m = e.slidesOffsetAfter.call(this)); const g = this.snapGrid.length; const b = this.snapGrid.length; let w = e.spaceBetween; let y = -f; let x = 0; let T = 0; if (void 0 !== s) {
        let E; let S; typeof w === 'string' && w.indexOf('%') >= 0 && (w = parseFloat(w.replace('%', '')) / 100 * s), this.virtualSize = -w, a ? d.css({ marginLeft: '', marginTop: '' }) : d.css({ marginRight: '', marginBottom: '' }), e.slidesPerColumn > 1 && (E = Math.floor(h / e.slidesPerColumn) === h / this.params.slidesPerColumn ? h : Math.ceil(h / e.slidesPerColumn) * e.slidesPerColumn, e.slidesPerView !== 'auto' && e.slidesPerColumnFill === 'row' && (E = Math.max(E, e.slidesPerView * e.slidesPerColumn))); for (var C, M = e.slidesPerColumn, P = E / M, z = Math.floor(h / e.slidesPerColumn), k = 0; k < h; k += 1) {
          S = 0; const $ = d.eq(k); if (e.slidesPerColumn > 1) {
            let L = void 0; let I = void 0; let D = void 0; if (e.slidesPerColumnFill === 'row' && e.slidesPerGroup > 1) {
              const O = Math.floor(k / (e.slidesPerGroup * e.slidesPerColumn)); const A = k - e.slidesPerColumn * e.slidesPerGroup * O; const G = O === 0 ? e.slidesPerGroup : Math.min(Math.ceil((h - O * M * e.slidesPerGroup) / M), e.slidesPerGroup); L = (I = A - (D = Math.floor(A / G)) * G + O * e.slidesPerGroup) + D * E / M, $.css({
                '-webkit-box-ordinal-group': L, '-moz-box-ordinal-group': L, '-ms-flex-order': L, '-webkit-order': L, order: L,
              });
            } else e.slidesPerColumnFill === 'column' ? (D = k - (I = Math.floor(k / M)) * M, (I > z || I === z && D === M - 1) && (D += 1) >= M && (D = 0, I += 1)) : I = k - (D = Math.floor(k / P)) * P; $.css(`margin-${this.isHorizontal() ? 'top' : 'left'}`, D !== 0 && e.spaceBetween && `${e.spaceBetween}px`);
          } if ($.css('display') !== 'none') { if (e.slidesPerView === 'auto') { const H = t.getComputedStyle($[0], null); const B = $[0].style.transform; const N = $[0].style.webkitTransform; if (B && ($[0].style.transform = 'none'), N && ($[0].style.webkitTransform = 'none'), e.roundLengths)S = this.isHorizontal() ? $.outerWidth(!0) : $.outerHeight(!0); else if (this.isHorizontal()) { const X = parseFloat(H.getPropertyValue('width')); const V = parseFloat(H.getPropertyValue('padding-left')); const Y = parseFloat(H.getPropertyValue('padding-right')); const F = parseFloat(H.getPropertyValue('margin-left')); const W = parseFloat(H.getPropertyValue('margin-right')); const R = H.getPropertyValue('box-sizing'); S = R && R === 'border-box' ? X + F + W : X + V + Y + F + W; } else { const q = parseFloat(H.getPropertyValue('height')); const j = parseFloat(H.getPropertyValue('padding-top')); const K = parseFloat(H.getPropertyValue('padding-bottom')); const U = parseFloat(H.getPropertyValue('margin-top')); const _ = parseFloat(H.getPropertyValue('margin-bottom')); const Z = H.getPropertyValue('box-sizing'); S = Z && Z === 'border-box' ? q + U + _ : q + j + K + U + _; }B && ($[0].style.transform = B), N && ($[0].style.webkitTransform = N), e.roundLengths && (S = Math.floor(S)); } else S = (s - (e.slidesPerView - 1) * w) / e.slidesPerView, e.roundLengths && (S = Math.floor(S)), d[k] && (this.isHorizontal() ? d[k].style.width = `${S}px` : d[k].style.height = `${S}px`); d[k] && (d[k].swiperSlideSize = S), u.push(S), e.centeredSlides ? (y = y + S / 2 + x / 2 + w, x === 0 && k !== 0 && (y = y - s / 2 - w), k === 0 && (y = y - s / 2 - w), Math.abs(y) < 0.001 && (y = 0), e.roundLengths && (y = Math.floor(y)), T % e.slidesPerGroup == 0 && p.push(y), c.push(y)) : (e.roundLengths && (y = Math.floor(y)), (T - Math.min(this.params.slidesPerGroupSkip, T)) % this.params.slidesPerGroup == 0 && p.push(y), c.push(y), y = y + S + w), this.virtualSize += S + w, x = S, T += 1; }
        } if (this.virtualSize = Math.max(this.virtualSize, s) + m, a && r && (e.effect === 'slide' || e.effect === 'coverflow') && i.css({ width: `${this.virtualSize + e.spaceBetween}px` }), e.setWrapperSize && (this.isHorizontal() ? i.css({ width: `${this.virtualSize + e.spaceBetween}px` }) : i.css({ height: `${this.virtualSize + e.spaceBetween}px` })), e.slidesPerColumn > 1 && (this.virtualSize = (S + e.spaceBetween) * E, this.virtualSize = Math.ceil(this.virtualSize / e.slidesPerColumn) - e.spaceBetween, this.isHorizontal() ? i.css({ width: `${this.virtualSize + e.spaceBetween}px` }) : i.css({ height: `${this.virtualSize + e.spaceBetween}px` }), e.centeredSlides)) { C = []; for (let Q = 0; Q < p.length; Q += 1) { let J = p[Q]; e.roundLengths && (J = Math.floor(J)), p[Q] < this.virtualSize + p[0] && C.push(J); }p = C; } if (!e.centeredSlides) { C = []; for (let ee = 0; ee < p.length; ee += 1) { let te = p[ee]; e.roundLengths && (te = Math.floor(te)), p[ee] <= this.virtualSize - s && C.push(te); }p = C, Math.floor(this.virtualSize - s) - Math.floor(p[p.length - 1]) > 1 && p.push(this.virtualSize - s); } if (p.length === 0 && (p = [0]), e.spaceBetween !== 0 && (this.isHorizontal() ? a ? d.filter(v).css({ marginLeft: `${w}px` }) : d.filter(v).css({ marginRight: `${w}px` }) : d.filter(v).css({ marginBottom: `${w}px` })), e.centeredSlides && e.centeredSlidesBounds) { let ie = 0; u.forEach(((t) => { ie += t + (e.spaceBetween ? e.spaceBetween : 0); })); const se = (ie -= e.spaceBetween) - s; p = p.map(((e) => (e < 0 ? -f : e > se ? se + m : e))); } if (e.centerInsufficientSlides) { let ae = 0; if (u.forEach(((t) => { ae += t + (e.spaceBetween ? e.spaceBetween : 0); })), (ae -= e.spaceBetween) < s) { const re = (s - ae) / 2; p.forEach(((e, t) => { p[t] = e - re; })), c.forEach(((e, t) => { c[t] = e + re; })); } }n.extend(this, {
          slides: d, snapGrid: p, slidesGrid: c, slidesSizesGrid: u,
        }), h !== l && this.emit('slidesLengthChange'), p.length !== g && (this.params.watchOverflow && this.checkOverflow(), this.emit('snapGridLengthChange')), c.length !== b && this.emit('slidesGridLengthChange'), (e.watchSlidesProgress || e.watchSlidesVisibility) && this.updateSlidesOffset();
      }
    },
    updateAutoHeight(e) { let t; const i = []; let s = 0; if (typeof e === 'number' ? this.setTransition(e) : !0 === e && this.setTransition(this.params.speed), this.params.slidesPerView !== 'auto' && this.params.slidesPerView > 1) if (this.params.centeredSlides) this.visibleSlides.each(((e, t) => { i.push(t); })); else for (t = 0; t < Math.ceil(this.params.slidesPerView); t += 1) { const a = this.activeIndex + t; if (a > this.slides.length) break; i.push(this.slides.eq(a)[0]); } else i.push(this.slides.eq(this.activeIndex)[0]); for (t = 0; t < i.length; t += 1) if (void 0 !== i[t]) { const r = i[t].offsetHeight; s = r > s ? r : s; }s && this.$wrapperEl.css('height', `${s}px`); },
    updateSlidesOffset() { for (let e = this.slides, t = 0; t < e.length; t += 1)e[t].swiperSlideOffset = this.isHorizontal() ? e[t].offsetLeft : e[t].offsetTop; },
    updateSlidesProgress(e) { void 0 === e && (e = this && this.translate || 0); const t = this.params; const i = this.slides; const a = this.rtlTranslate; if (i.length !== 0) { void 0 === i[0].swiperSlideOffset && this.updateSlidesOffset(); let r = -e; a && (r = e), i.removeClass(t.slideVisibleClass), this.visibleSlidesIndexes = [], this.visibleSlides = []; for (let n = 0; n < i.length; n += 1) { const o = i[n]; const l = (r + (t.centeredSlides ? this.minTranslate() : 0) - o.swiperSlideOffset) / (o.swiperSlideSize + t.spaceBetween); if (t.watchSlidesVisibility || t.centeredSlides && t.autoHeight) { const d = -(r - o.swiperSlideOffset); const h = d + this.slidesSizesGrid[n]; (d >= 0 && d < this.size - 1 || h > 1 && h <= this.size || d <= 0 && h >= this.size) && (this.visibleSlides.push(o), this.visibleSlidesIndexes.push(n), i.eq(n).addClass(t.slideVisibleClass)); }o.progress = a ? -l : l; } this.visibleSlides = s(this.visibleSlides); } },
    updateProgress(e) { if (void 0 === e) { const t = this.rtlTranslate ? -1 : 1; e = this && this.translate && this.translate * t || 0; } const i = this.params; const s = this.maxTranslate() - this.minTranslate(); let a = this.progress; let r = this.isBeginning; let o = this.isEnd; const l = r; const d = o; s === 0 ? (a = 0, r = !0, o = !0) : (r = (a = (e - this.minTranslate()) / s) <= 0, o = a >= 1), n.extend(this, { progress: a, isBeginning: r, isEnd: o }), (i.watchSlidesProgress || i.watchSlidesVisibility || i.centeredSlides && i.autoHeight) && this.updateSlidesProgress(e), r && !l && this.emit('reachBeginning toEdge'), o && !d && this.emit('reachEnd toEdge'), (l && !r || d && !o) && this.emit('fromEdge'), this.emit('progress', a); },
    updateSlidesClasses() { let e; const t = this.slides; const i = this.params; const s = this.$wrapperEl; const a = this.activeIndex; const r = this.realIndex; const n = this.virtual && i.virtual.enabled; t.removeClass(`${i.slideActiveClass} ${i.slideNextClass} ${i.slidePrevClass} ${i.slideDuplicateActiveClass} ${i.slideDuplicateNextClass} ${i.slideDuplicatePrevClass}`), (e = n ? this.$wrapperEl.find(`.${i.slideClass}[data-swiper-slide-index="${a}"]`) : t.eq(a)).addClass(i.slideActiveClass), i.loop && (e.hasClass(i.slideDuplicateClass) ? s.children(`.${i.slideClass}:not(.${i.slideDuplicateClass})[data-swiper-slide-index="${r}"]`).addClass(i.slideDuplicateActiveClass) : s.children(`.${i.slideClass}.${i.slideDuplicateClass}[data-swiper-slide-index="${r}"]`).addClass(i.slideDuplicateActiveClass)); let o = e.nextAll(`.${i.slideClass}`).eq(0).addClass(i.slideNextClass); i.loop && o.length === 0 && (o = t.eq(0)).addClass(i.slideNextClass); let l = e.prevAll(`.${i.slideClass}`).eq(0).addClass(i.slidePrevClass); i.loop && l.length === 0 && (l = t.eq(-1)).addClass(i.slidePrevClass), i.loop && (o.hasClass(i.slideDuplicateClass) ? s.children(`.${i.slideClass}:not(.${i.slideDuplicateClass})[data-swiper-slide-index="${o.attr('data-swiper-slide-index')}"]`).addClass(i.slideDuplicateNextClass) : s.children(`.${i.slideClass}.${i.slideDuplicateClass}[data-swiper-slide-index="${o.attr('data-swiper-slide-index')}"]`).addClass(i.slideDuplicateNextClass), l.hasClass(i.slideDuplicateClass) ? s.children(`.${i.slideClass}:not(.${i.slideDuplicateClass})[data-swiper-slide-index="${l.attr('data-swiper-slide-index')}"]`).addClass(i.slideDuplicatePrevClass) : s.children(`.${i.slideClass}.${i.slideDuplicateClass}[data-swiper-slide-index="${l.attr('data-swiper-slide-index')}"]`).addClass(i.slideDuplicatePrevClass)); },
    updateActiveIndex(e) {
      let t; const i = this.rtlTranslate ? this.translate : -this.translate; const s = this.slidesGrid; const a = this.snapGrid; const r = this.params; const o = this.activeIndex; const l = this.realIndex; const d = this.snapIndex; let h = e; if (void 0 === h) { for (let p = 0; p < s.length; p += 1) void 0 !== s[p + 1] ? i >= s[p] && i < s[p + 1] - (s[p + 1] - s[p]) / 2 ? h = p : i >= s[p] && i < s[p + 1] && (h = p + 1) : i >= s[p] && (h = p); r.normalizeSlideIndex && (h < 0 || void 0 === h) && (h = 0); } if (a.indexOf(i) >= 0)t = a.indexOf(i); else { const c = Math.min(r.slidesPerGroupSkip, h); t = c + Math.floor((h - c) / r.slidesPerGroup); } if (t >= a.length && (t = a.length - 1), h !== o) {
        const u = parseInt(this.slides.eq(h).attr('data-swiper-slide-index') || h, 10); n.extend(this, {
          snapIndex: t, realIndex: u, previousIndex: o, activeIndex: h,
        }), this.emit('activeIndexChange'), this.emit('snapIndexChange'), l !== u && this.emit('realIndexChange'), (this.initialized || this.params.runCallbacksOnInit) && this.emit('slideChange');
      } else t !== d && (this.snapIndex = t, this.emit('snapIndexChange'));
    },
    updateClickedSlide(e) { const t = this.params; const i = s(e.target).closest(`.${t.slideClass}`)[0]; let a = !1; if (i) for (let r = 0; r < this.slides.length; r += 1) this.slides[r] === i && (a = !0); if (!i || !a) return this.clickedSlide = void 0, void (this.clickedIndex = void 0); this.clickedSlide = i, this.virtual && this.params.virtual.enabled ? this.clickedIndex = parseInt(s(i).attr('data-swiper-slide-index'), 10) : this.clickedIndex = s(i).index(), t.slideToClickedSlide && void 0 !== this.clickedIndex && this.clickedIndex !== this.activeIndex && this.slideToClickedSlide(); },
  }; const p = {
    getTranslate(e) { void 0 === e && (e = this.isHorizontal() ? 'x' : 'y'); const t = this.params; const i = this.rtlTranslate; const s = this.translate; const a = this.$wrapperEl; if (t.virtualTranslate) return i ? -s : s; if (t.cssMode) return s; let r = n.getTranslate(a[0], e); return i && (r = -r), r || 0; }, setTranslate(e, t) { const i = this.rtlTranslate; const s = this.params; const a = this.$wrapperEl; const r = this.wrapperEl; const n = this.progress; let o = 0; let l = 0; this.isHorizontal() ? o = i ? -e : e : l = e, s.roundLengths && (o = Math.floor(o), l = Math.floor(l)), s.cssMode ? r[this.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = this.isHorizontal() ? -o : -l : s.virtualTranslate || a.transform(`translate3d(${o}px, ${l}px, 0px)`), this.previousTranslate = this.translate, this.translate = this.isHorizontal() ? o : l; const d = this.maxTranslate() - this.minTranslate(); (d === 0 ? 0 : (e - this.minTranslate()) / d) !== n && this.updateProgress(e), this.emit('setTranslate', this.translate, t); }, minTranslate() { return -this.snapGrid[0]; }, maxTranslate() { return -this.snapGrid[this.snapGrid.length - 1]; }, translateTo(e, t, i, s, a) { let r; void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === i && (i = !0), void 0 === s && (s = !0); const n = this; const o = n.params; const l = n.wrapperEl; if (n.animating && o.preventInteractionOnTransition) return !1; let d; const h = n.minTranslate(); const p = n.maxTranslate(); if (d = s && e > h ? h : s && e < p ? p : e, n.updateProgress(d), o.cssMode) { const c = n.isHorizontal(); return t === 0 ? l[c ? 'scrollLeft' : 'scrollTop'] = -d : l.scrollTo ? l.scrollTo(((r = {})[c ? 'left' : 'top'] = -d, r.behavior = 'smooth', r)) : l[c ? 'scrollLeft' : 'scrollTop'] = -d, !0; } return t === 0 ? (n.setTransition(0), n.setTranslate(d), i && (n.emit('beforeTransitionStart', t, a), n.emit('transitionEnd'))) : (n.setTransition(t), n.setTranslate(d), i && (n.emit('beforeTransitionStart', t, a), n.emit('transitionStart')), n.animating || (n.animating = !0, n.onTranslateToWrapperTransitionEnd || (n.onTranslateToWrapperTransitionEnd = function (e) { n && !n.destroyed && e.target === this && (n.$wrapperEl[0].removeEventListener('transitionend', n.onTranslateToWrapperTransitionEnd), n.$wrapperEl[0].removeEventListener('webkitTransitionEnd', n.onTranslateToWrapperTransitionEnd), n.onTranslateToWrapperTransitionEnd = null, delete n.onTranslateToWrapperTransitionEnd, i && n.emit('transitionEnd')); }), n.$wrapperEl[0].addEventListener('transitionend', n.onTranslateToWrapperTransitionEnd), n.$wrapperEl[0].addEventListener('webkitTransitionEnd', n.onTranslateToWrapperTransitionEnd))), !0; },
  }; const c = { setTransition(e, t) { this.params.cssMode || this.$wrapperEl.transition(e), this.emit('setTransition', e, t); }, transitionStart(e, t) { void 0 === e && (e = !0); const i = this.activeIndex; const s = this.params; const a = this.previousIndex; if (!s.cssMode) { s.autoHeight && this.updateAutoHeight(); let r = t; if (r || (r = i > a ? 'next' : i < a ? 'prev' : 'reset'), this.emit('transitionStart'), e && i !== a) { if (r === 'reset') return void this.emit('slideResetTransitionStart'); this.emit('slideChangeTransitionStart'), r === 'next' ? this.emit('slideNextTransitionStart') : this.emit('slidePrevTransitionStart'); } } }, transitionEnd(e, t) { void 0 === e && (e = !0); const i = this.activeIndex; const s = this.previousIndex; const a = this.params; if (this.animating = !1, !a.cssMode) { this.setTransition(0); let r = t; if (r || (r = i > s ? 'next' : i < s ? 'prev' : 'reset'), this.emit('transitionEnd'), e && i !== s) { if (r === 'reset') return void this.emit('slideResetTransitionEnd'); this.emit('slideChangeTransitionEnd'), r === 'next' ? this.emit('slideNextTransitionEnd') : this.emit('slidePrevTransitionEnd'); } } } }; const u = {
    slideTo(e, t, i, s) { let a; void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === i && (i = !0); const r = this; let n = e; n < 0 && (n = 0); const o = r.params; const l = r.snapGrid; const d = r.slidesGrid; const h = r.previousIndex; const p = r.activeIndex; const c = r.rtlTranslate; const u = r.wrapperEl; if (r.animating && o.preventInteractionOnTransition) return !1; const v = Math.min(r.params.slidesPerGroupSkip, n); let f = v + Math.floor((n - v) / r.params.slidesPerGroup); f >= l.length && (f = l.length - 1), (p || o.initialSlide || 0) === (h || 0) && i && r.emit('beforeSlideChangeStart'); let m; const g = -l[f]; if (r.updateProgress(g), o.normalizeSlideIndex) for (let b = 0; b < d.length; b += 1)-Math.floor(100 * g) >= Math.floor(100 * d[b]) && (n = b); if (r.initialized && n !== p) { if (!r.allowSlideNext && g < r.translate && g < r.minTranslate()) return !1; if (!r.allowSlidePrev && g > r.translate && g > r.maxTranslate() && (p || 0) !== n) return !1; } if (m = n > p ? 'next' : n < p ? 'prev' : 'reset', c && -g === r.translate || !c && g === r.translate) return r.updateActiveIndex(n), o.autoHeight && r.updateAutoHeight(), r.updateSlidesClasses(), o.effect !== 'slide' && r.setTranslate(g), m !== 'reset' && (r.transitionStart(i, m), r.transitionEnd(i, m)), !1; if (o.cssMode) { const w = r.isHorizontal(); let y = -g; return c && (y = u.scrollWidth - u.offsetWidth - y), t === 0 ? u[w ? 'scrollLeft' : 'scrollTop'] = y : u.scrollTo ? u.scrollTo(((a = {})[w ? 'left' : 'top'] = y, a.behavior = 'smooth', a)) : u[w ? 'scrollLeft' : 'scrollTop'] = y, !0; } return t === 0 ? (r.setTransition(0), r.setTranslate(g), r.updateActiveIndex(n), r.updateSlidesClasses(), r.emit('beforeTransitionStart', t, s), r.transitionStart(i, m), r.transitionEnd(i, m)) : (r.setTransition(t), r.setTranslate(g), r.updateActiveIndex(n), r.updateSlidesClasses(), r.emit('beforeTransitionStart', t, s), r.transitionStart(i, m), r.animating || (r.animating = !0, r.onSlideToWrapperTransitionEnd || (r.onSlideToWrapperTransitionEnd = function (e) { r && !r.destroyed && e.target === this && (r.$wrapperEl[0].removeEventListener('transitionend', r.onSlideToWrapperTransitionEnd), r.$wrapperEl[0].removeEventListener('webkitTransitionEnd', r.onSlideToWrapperTransitionEnd), r.onSlideToWrapperTransitionEnd = null, delete r.onSlideToWrapperTransitionEnd, r.transitionEnd(i, m)); }), r.$wrapperEl[0].addEventListener('transitionend', r.onSlideToWrapperTransitionEnd), r.$wrapperEl[0].addEventListener('webkitTransitionEnd', r.onSlideToWrapperTransitionEnd))), !0; }, slideToLoop(e, t, i, s) { void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === i && (i = !0); let a = e; return this.params.loop && (a += this.loopedSlides), this.slideTo(a, t, i, s); }, slideNext(e, t, i) { void 0 === e && (e = this.params.speed), void 0 === t && (t = !0); const s = this.params; const a = this.animating; const r = this.activeIndex < s.slidesPerGroupSkip ? 1 : s.slidesPerGroup; if (s.loop) { if (a) return !1; this.loopFix(), this._clientLeft = this.$wrapperEl[0].clientLeft; } return this.slideTo(this.activeIndex + r, e, t, i); }, slidePrev(e, t, i) { void 0 === e && (e = this.params.speed), void 0 === t && (t = !0); const s = this.params; const a = this.animating; const r = this.snapGrid; const n = this.slidesGrid; const o = this.rtlTranslate; if (s.loop) { if (a) return !1; this.loopFix(), this._clientLeft = this.$wrapperEl[0].clientLeft; } function l(e) { return e < 0 ? -Math.floor(Math.abs(e)) : Math.floor(e); } let d; const h = l(o ? this.translate : -this.translate); const p = r.map(((e) => l(e))); let c = (n.map(((e) => l(e))), r[p.indexOf(h)], r[p.indexOf(h) - 1]); return void 0 === c && s.cssMode && r.forEach(((e) => { !c && h >= e && (c = e); })), void 0 !== c && (d = n.indexOf(c)) < 0 && (d = this.activeIndex - 1), this.slideTo(d, e, t, i); }, slideReset(e, t, i) { return void 0 === e && (e = this.params.speed), void 0 === t && (t = !0), this.slideTo(this.activeIndex, e, t, i); }, slideToClosest(e, t, i, s) { void 0 === e && (e = this.params.speed), void 0 === t && (t = !0), void 0 === s && (s = 0.5); let a = this.activeIndex; const r = Math.min(this.params.slidesPerGroupSkip, a); const n = r + Math.floor((a - r) / this.params.slidesPerGroup); const o = this.rtlTranslate ? this.translate : -this.translate; if (o >= this.snapGrid[n]) { const l = this.snapGrid[n]; o - l > (this.snapGrid[n + 1] - l) * s && (a += this.params.slidesPerGroup); } else { const d = this.snapGrid[n - 1]; o - d <= (this.snapGrid[n] - d) * s && (a -= this.params.slidesPerGroup); } return a = Math.max(a, 0), a = Math.min(a, this.slidesGrid.length - 1), this.slideTo(a, e, t, i); }, slideToClickedSlide() { let e; const t = this; const i = t.params; const a = t.$wrapperEl; const r = i.slidesPerView === 'auto' ? t.slidesPerViewDynamic() : i.slidesPerView; let o = t.clickedIndex; if (i.loop) { if (t.animating) return; e = parseInt(s(t.clickedSlide).attr('data-swiper-slide-index'), 10), i.centeredSlides ? o < t.loopedSlides - r / 2 || o > t.slides.length - t.loopedSlides + r / 2 ? (t.loopFix(), o = a.children(`.${i.slideClass}[data-swiper-slide-index="${e}"]:not(.${i.slideDuplicateClass})`).eq(0).index(), n.nextTick((() => { t.slideTo(o); }))) : t.slideTo(o) : o > t.slides.length - r ? (t.loopFix(), o = a.children(`.${i.slideClass}[data-swiper-slide-index="${e}"]:not(.${i.slideDuplicateClass})`).eq(0).index(), n.nextTick((() => { t.slideTo(o); }))) : t.slideTo(o); } else t.slideTo(o); },
  }; const v = { loopCreate() { const t = this; const i = t.params; const a = t.$wrapperEl; a.children(`.${i.slideClass}.${i.slideDuplicateClass}`).remove(); let r = a.children(`.${i.slideClass}`); if (i.loopFillGroupWithBlank) { const n = i.slidesPerGroup - r.length % i.slidesPerGroup; if (n !== i.slidesPerGroup) { for (let o = 0; o < n; o += 1) { const l = s(e.createElement('div')).addClass(`${i.slideClass} ${i.slideBlankClass}`); a.append(l); }r = a.children(`.${i.slideClass}`); } }i.slidesPerView !== 'auto' || i.loopedSlides || (i.loopedSlides = r.length), t.loopedSlides = Math.ceil(parseFloat(i.loopedSlides || i.slidesPerView, 10)), t.loopedSlides += i.loopAdditionalSlides, t.loopedSlides > r.length && (t.loopedSlides = r.length); const d = []; const h = []; r.each(((e, i) => { const a = s(i); e < t.loopedSlides && h.push(i), e < r.length && e >= r.length - t.loopedSlides && d.push(i), a.attr('data-swiper-slide-index', e); })); for (let p = 0; p < h.length; p += 1)a.append(s(h[p].cloneNode(!0)).addClass(i.slideDuplicateClass)); for (let c = d.length - 1; c >= 0; c -= 1)a.prepend(s(d[c].cloneNode(!0)).addClass(i.slideDuplicateClass)); }, loopFix() { this.emit('beforeLoopFix'); let e; const t = this.activeIndex; const i = this.slides; const s = this.loopedSlides; const a = this.allowSlidePrev; const r = this.allowSlideNext; const n = this.snapGrid; const o = this.rtlTranslate; this.allowSlidePrev = !0, this.allowSlideNext = !0; const l = -n[t] - this.getTranslate(); if (t < s)e = i.length - 3 * s + t, e += s, this.slideTo(e, 0, !1, !0) && l !== 0 && this.setTranslate((o ? -this.translate : this.translate) - l); else if (t >= i.length - s) { e = -i.length + t + s, e += s, this.slideTo(e, 0, !1, !0) && l !== 0 && this.setTranslate((o ? -this.translate : this.translate) - l); } this.allowSlidePrev = a, this.allowSlideNext = r, this.emit('loopFix'); }, loopDestroy() { const e = this.$wrapperEl; const t = this.params; const i = this.slides; e.children(`.${t.slideClass}.${t.slideDuplicateClass},.${t.slideClass}.${t.slideBlankClass}`).remove(), i.removeAttr('data-swiper-slide-index'); } }; const f = { setGrabCursor(e) { if (!(o.touch || !this.params.simulateTouch || this.params.watchOverflow && this.isLocked || this.params.cssMode)) { const t = this.el; t.style.cursor = 'move', t.style.cursor = e ? '-webkit-grabbing' : '-webkit-grab', t.style.cursor = e ? '-moz-grabbin' : '-moz-grab', t.style.cursor = e ? 'grabbing' : 'grab'; } }, unsetGrabCursor() { o.touch || this.params.watchOverflow && this.isLocked || this.params.cssMode || (this.el.style.cursor = ''); } }; let m; let g; let b; let w; let y; let x; let T; let E; let S; let C; let M; let P; let z; let k; let $; const L = {
    appendSlide(e) { const t = this.$wrapperEl; const i = this.params; if (i.loop && this.loopDestroy(), typeof e === 'object' && 'length' in e) for (let s = 0; s < e.length; s += 1)e[s] && t.append(e[s]); else t.append(e); i.loop && this.loopCreate(), i.observer && o.observer || this.update(); }, prependSlide(e) { const t = this.params; const i = this.$wrapperEl; const s = this.activeIndex; t.loop && this.loopDestroy(); let a = s + 1; if (typeof e === 'object' && 'length' in e) { for (let r = 0; r < e.length; r += 1)e[r] && i.prepend(e[r]); a = s + e.length; } else i.prepend(e); t.loop && this.loopCreate(), t.observer && o.observer || this.update(), this.slideTo(a, 0, !1); }, addSlide(e, t) { const i = this.$wrapperEl; const s = this.params; let a = this.activeIndex; s.loop && (a -= this.loopedSlides, this.loopDestroy(), this.slides = i.children(`.${s.slideClass}`)); const r = this.slides.length; if (e <= 0) this.prependSlide(t); else if (e >= r) this.appendSlide(t); else { for (var n = a > e ? a + 1 : a, l = [], d = r - 1; d >= e; d -= 1) { const h = this.slides.eq(d); h.remove(), l.unshift(h); } if (typeof t === 'object' && 'length' in t) { for (let p = 0; p < t.length; p += 1)t[p] && i.append(t[p]); n = a > e ? a + t.length : a; } else i.append(t); for (let c = 0; c < l.length; c += 1)i.append(l[c]); s.loop && this.loopCreate(), s.observer && o.observer || this.update(), s.loop ? this.slideTo(n + this.loopedSlides, 0, !1) : this.slideTo(n, 0, !1); } }, removeSlide(e) { const t = this.params; const i = this.$wrapperEl; let s = this.activeIndex; t.loop && (s -= this.loopedSlides, this.loopDestroy(), this.slides = i.children(`.${t.slideClass}`)); let a; let r = s; if (typeof e === 'object' && 'length' in e) { for (let n = 0; n < e.length; n += 1)a = e[n], this.slides[a] && this.slides.eq(a).remove(), a < r && (r -= 1); r = Math.max(r, 0); } else a = e, this.slides[a] && this.slides.eq(a).remove(), a < r && (r -= 1), r = Math.max(r, 0); t.loop && this.loopCreate(), t.observer && o.observer || this.update(), t.loop ? this.slideTo(r + this.loopedSlides, 0, !1) : this.slideTo(r, 0, !1); }, removeAllSlides() { for (var e = [], t = 0; t < this.slides.length; t += 1)e.push(t); this.removeSlide(e); },
  }; const I = (m = t.navigator.platform, g = t.navigator.userAgent, b = {
    ios: !1, android: !1, androidChrome: !1, desktop: !1, iphone: !1, ipod: !1, ipad: !1, edge: !1, ie: !1, firefox: !1, macos: !1, windows: !1, cordova: !(!t.cordova && !t.phonegap), phonegap: !(!t.cordova && !t.phonegap), electron: !1,
  }, w = t.screen.width, y = t.screen.height, x = g.match(/(Android);?[\s\/]+([\d.]+)?/), T = g.match(/(iPad).*OS\s([\d_]+)/), E = g.match(/(iPod)(.*OS\s([\d_]+))?/), S = !T && g.match(/(iPhone\sOS|iOS)\s([\d_]+)/), C = g.indexOf('MSIE ') >= 0 || g.indexOf('Trident/') >= 0, M = g.indexOf('Edge/') >= 0, P = g.indexOf('Gecko/') >= 0 && g.indexOf('Firefox/') >= 0, z = m === 'Win32', k = g.toLowerCase().indexOf('electron') >= 0, $ = m === 'MacIntel', !T && $ && o.touch && (w === 1024 && y === 1366 || w === 834 && y === 1194 || w === 834 && y === 1112 || w === 768 && y === 1024) && (T = g.match(/(Version)\/([\d.]+)/), $ = !1), b.ie = C, b.edge = M, b.firefox = P, x && !z && (b.os = 'android', b.osVersion = x[2], b.android = !0, b.androidChrome = g.toLowerCase().indexOf('chrome') >= 0), (T || S || E) && (b.os = 'ios', b.ios = !0), S && !E && (b.osVersion = S[2].replace(/_/g, '.'), b.iphone = !0), T && (b.osVersion = T[2].replace(/_/g, '.'), b.ipad = !0), E && (b.osVersion = E[3] ? E[3].replace(/_/g, '.') : null, b.ipod = !0), b.ios && b.osVersion && g.indexOf('Version/') >= 0 && b.osVersion.split('.')[0] === '10' && (b.osVersion = g.toLowerCase().split('version/')[1].split(' ')[0]), b.webView = !(!(S || T || E) || !g.match(/.*AppleWebKit(?!.*Safari)/i) && !t.navigator.standalone) || t.matchMedia && t.matchMedia('(display-mode: standalone)').matches, b.webview = b.webView, b.standalone = b.webView, b.desktop = !(b.ios || b.android) || k, b.desktop && (b.electron = k, b.macos = $, b.windows = z, b.macos && (b.os = 'macos'), b.windows && (b.os = 'windows')), b.pixelRatio = t.devicePixelRatio || 1, b); function D(i) {
    const a = this.touchEventsData; const r = this.params; const o = this.touches; if (!this.animating || !r.preventInteractionOnTransition) {
      let l = i; l.originalEvent && (l = l.originalEvent); const d = s(l.target); if ((r.touchEventsTarget !== 'wrapper' || d.closest(this.wrapperEl).length) && (a.isTouchEvent = l.type === 'touchstart', (a.isTouchEvent || !('which' in l) || l.which !== 3) && !(!a.isTouchEvent && 'button' in l && l.button > 0 || a.isTouched && a.isMoved))) {
        if (r.noSwiping && d.closest(r.noSwipingSelector ? r.noSwipingSelector : `.${r.noSwipingClass}`)[0]) this.allowClick = !0; else if (!r.swipeHandler || d.closest(r.swipeHandler)[0]) {
          o.currentX = l.type === 'touchstart' ? l.targetTouches[0].pageX : l.pageX, o.currentY = l.type === 'touchstart' ? l.targetTouches[0].pageY : l.pageY; const h = o.currentX; const p = o.currentY; const c = r.edgeSwipeDetection || r.iOSEdgeSwipeDetection; const u = r.edgeSwipeThreshold || r.iOSEdgeSwipeThreshold; if (!c || !(h <= u || h >= t.screen.width - u)) {
            if (n.extend(a, {
              isTouched: !0, isMoved: !1, allowTouchCallbacks: !0, isScrolling: void 0, startMoving: void 0,
            }), o.startX = h, o.startY = p, a.touchStartTime = n.now(), this.allowClick = !0, this.updateSize(), this.swipeDirection = void 0, r.threshold > 0 && (a.allowThresholdMove = !1), l.type !== 'touchstart') { let v = !0; d.is(a.formElements) && (v = !1), e.activeElement && s(e.activeElement).is(a.formElements) && e.activeElement !== d[0] && e.activeElement.blur(); const f = v && this.allowTouchMove && r.touchStartPreventDefault; (r.touchStartForcePreventDefault || f) && l.preventDefault(); } this.emit('touchStart', l);
          }
        }
      }
    }
  } function O(t) {
    const i = this.touchEventsData; const a = this.params; const r = this.touches; const o = this.rtlTranslate; let l = t; if (l.originalEvent && (l = l.originalEvent), i.isTouched) {
      if (!i.isTouchEvent || l.type !== 'mousemove') {
        const d = l.type === 'touchmove' && l.targetTouches && (l.targetTouches[0] || l.changedTouches[0]); const h = l.type === 'touchmove' ? d.pageX : l.pageX; const p = l.type === 'touchmove' ? d.pageY : l.pageY; if (l.preventedByNestedSwiper) return r.startX = h, void (r.startY = p); if (!this.allowTouchMove) {
          return this.allowClick = !1, void (i.isTouched && (n.extend(r, {
            startX: h, startY: p, currentX: h, currentY: p,
          }), i.touchStartTime = n.now()));
        } if (i.isTouchEvent && a.touchReleaseOnEdges && !a.loop) if (this.isVertical()) { if (p < r.startY && this.translate <= this.maxTranslate() || p > r.startY && this.translate >= this.minTranslate()) return i.isTouched = !1, void (i.isMoved = !1); } else if (h < r.startX && this.translate <= this.maxTranslate() || h > r.startX && this.translate >= this.minTranslate()) return; if (i.isTouchEvent && e.activeElement && l.target === e.activeElement && s(l.target).is(i.formElements)) return i.isMoved = !0, void (this.allowClick = !1); if (i.allowTouchCallbacks && this.emit('touchMove', l), !(l.targetTouches && l.targetTouches.length > 1)) { r.currentX = h, r.currentY = p; const c = r.currentX - r.startX; const u = r.currentY - r.startY; if (!(this.params.threshold && Math.sqrt(Math.pow(c, 2) + Math.pow(u, 2)) < this.params.threshold)) { let v; if (void 0 === i.isScrolling) this.isHorizontal() && r.currentY === r.startY || this.isVertical() && r.currentX === r.startX ? i.isScrolling = !1 : c * c + u * u >= 25 && (v = 180 * Math.atan2(Math.abs(u), Math.abs(c)) / Math.PI, i.isScrolling = this.isHorizontal() ? v > a.touchAngle : 90 - v > a.touchAngle); if (i.isScrolling && this.emit('touchMoveOpposite', l), void 0 === i.startMoving && (r.currentX === r.startX && r.currentY === r.startY || (i.startMoving = !0)), i.isScrolling)i.isTouched = !1; else if (i.startMoving) { this.allowClick = !1, a.cssMode || l.preventDefault(), a.touchMoveStopPropagation && !a.nested && l.stopPropagation(), i.isMoved || (a.loop && this.loopFix(), i.startTranslate = this.getTranslate(), this.setTransition(0), this.animating && this.$wrapperEl.trigger('webkitTransitionEnd transitionend'), i.allowMomentumBounce = !1, !a.grabCursor || !0 !== this.allowSlideNext && !0 !== this.allowSlidePrev || this.setGrabCursor(!0), this.emit('sliderFirstMove', l)), this.emit('sliderMove', l), i.isMoved = !0; let f = this.isHorizontal() ? c : u; r.diff = f, f *= a.touchRatio, o && (f = -f), this.swipeDirection = f > 0 ? 'prev' : 'next', i.currentTranslate = f + i.startTranslate; let m = !0; let g = a.resistanceRatio; if (a.touchReleaseOnEdges && (g = 0), f > 0 && i.currentTranslate > this.minTranslate() ? (m = !1, a.resistance && (i.currentTranslate = this.minTranslate() - 1 + Math.pow(-this.minTranslate() + i.startTranslate + f, g))) : f < 0 && i.currentTranslate < this.maxTranslate() && (m = !1, a.resistance && (i.currentTranslate = this.maxTranslate() + 1 - Math.pow(this.maxTranslate() - i.startTranslate - f, g))), m && (l.preventedByNestedSwiper = !0), !this.allowSlideNext && this.swipeDirection === 'next' && i.currentTranslate < i.startTranslate && (i.currentTranslate = i.startTranslate), !this.allowSlidePrev && this.swipeDirection === 'prev' && i.currentTranslate > i.startTranslate && (i.currentTranslate = i.startTranslate), a.threshold > 0) { if (!(Math.abs(f) > a.threshold || i.allowThresholdMove)) return void (i.currentTranslate = i.startTranslate); if (!i.allowThresholdMove) return i.allowThresholdMove = !0, r.startX = r.currentX, r.startY = r.currentY, i.currentTranslate = i.startTranslate, void (r.diff = this.isHorizontal() ? r.currentX - r.startX : r.currentY - r.startY); }a.followFinger && !a.cssMode && ((a.freeMode || a.watchSlidesProgress || a.watchSlidesVisibility) && (this.updateActiveIndex(), this.updateSlidesClasses()), a.freeMode && (i.velocities.length === 0 && i.velocities.push({ position: r[this.isHorizontal() ? 'startX' : 'startY'], time: i.touchStartTime }), i.velocities.push({ position: r[this.isHorizontal() ? 'currentX' : 'currentY'], time: n.now() })), this.updateProgress(i.currentTranslate), this.setTranslate(i.currentTranslate)); } } }
      }
    } else i.startMoving && i.isScrolling && this.emit('touchMoveOpposite', l);
  } function A(e) { const t = this; const i = t.touchEventsData; const s = t.params; const a = t.touches; const r = t.rtlTranslate; const o = t.$wrapperEl; const l = t.slidesGrid; const d = t.snapGrid; let h = e; if (h.originalEvent && (h = h.originalEvent), i.allowTouchCallbacks && t.emit('touchEnd', h), i.allowTouchCallbacks = !1, !i.isTouched) return i.isMoved && s.grabCursor && t.setGrabCursor(!1), i.isMoved = !1, void (i.startMoving = !1); s.grabCursor && i.isMoved && i.isTouched && (!0 === t.allowSlideNext || !0 === t.allowSlidePrev) && t.setGrabCursor(!1); let p; const c = n.now(); const u = c - i.touchStartTime; if (t.allowClick && (t.updateClickedSlide(h), t.emit('tap click', h), u < 300 && c - i.lastClickTime < 300 && t.emit('doubleTap doubleClick', h)), i.lastClickTime = n.now(), n.nextTick((() => { t.destroyed || (t.allowClick = !0); })), !i.isTouched || !i.isMoved || !t.swipeDirection || a.diff === 0 || i.currentTranslate === i.startTranslate) return i.isTouched = !1, i.isMoved = !1, void (i.startMoving = !1); if (i.isTouched = !1, i.isMoved = !1, i.startMoving = !1, p = s.followFinger ? r ? t.translate : -t.translate : -i.currentTranslate, !s.cssMode) if (s.freeMode) { if (p < -t.minTranslate()) return void t.slideTo(t.activeIndex); if (p > -t.maxTranslate()) return void (t.slides.length < d.length ? t.slideTo(d.length - 1) : t.slideTo(t.slides.length - 1)); if (s.freeModeMomentum) { if (i.velocities.length > 1) { const v = i.velocities.pop(); const f = i.velocities.pop(); const m = v.position - f.position; const g = v.time - f.time; t.velocity = m / g, t.velocity /= 2, Math.abs(t.velocity) < s.freeModeMinimumVelocity && (t.velocity = 0), (g > 150 || n.now() - v.time > 300) && (t.velocity = 0); } else t.velocity = 0; t.velocity *= s.freeModeMomentumVelocityRatio, i.velocities.length = 0; let b = 1e3 * s.freeModeMomentumRatio; const w = t.velocity * b; let y = t.translate + w; r && (y = -y); let x; let T; let E = !1; const S = 20 * Math.abs(t.velocity) * s.freeModeMomentumBounceRatio; if (y < t.maxTranslate())s.freeModeMomentumBounce ? (y + t.maxTranslate() < -S && (y = t.maxTranslate() - S), x = t.maxTranslate(), E = !0, i.allowMomentumBounce = !0) : y = t.maxTranslate(), s.loop && s.centeredSlides && (T = !0); else if (y > t.minTranslate())s.freeModeMomentumBounce ? (y - t.minTranslate() > S && (y = t.minTranslate() + S), x = t.minTranslate(), E = !0, i.allowMomentumBounce = !0) : y = t.minTranslate(), s.loop && s.centeredSlides && (T = !0); else if (s.freeModeSticky) { for (var C, M = 0; M < d.length; M += 1) if (d[M] > -y) { C = M; break; }y = -(y = Math.abs(d[C] - y) < Math.abs(d[C - 1] - y) || t.swipeDirection === 'next' ? d[C] : d[C - 1]); } if (T && t.once('transitionEnd', (() => { t.loopFix(); })), t.velocity !== 0) { if (b = r ? Math.abs((-y - t.translate) / t.velocity) : Math.abs((y - t.translate) / t.velocity), s.freeModeSticky) { const P = Math.abs((r ? -y : y) - t.translate); const z = t.slidesSizesGrid[t.activeIndex]; b = P < z ? s.speed : P < 2 * z ? 1.5 * s.speed : 2.5 * s.speed; } } else if (s.freeModeSticky) return void t.slideToClosest(); s.freeModeMomentumBounce && E ? (t.updateProgress(x), t.setTransition(b), t.setTranslate(y), t.transitionStart(!0, t.swipeDirection), t.animating = !0, o.transitionEnd((() => { t && !t.destroyed && i.allowMomentumBounce && (t.emit('momentumBounce'), t.setTransition(s.speed), setTimeout((() => { t.setTranslate(x), o.transitionEnd((() => { t && !t.destroyed && t.transitionEnd(); })); }), 0)); }))) : t.velocity ? (t.updateProgress(y), t.setTransition(b), t.setTranslate(y), t.transitionStart(!0, t.swipeDirection), t.animating || (t.animating = !0, o.transitionEnd((() => { t && !t.destroyed && t.transitionEnd(); })))) : t.updateProgress(y), t.updateActiveIndex(), t.updateSlidesClasses(); } else if (s.freeModeSticky) return void t.slideToClosest(); (!s.freeModeMomentum || u >= s.longSwipesMs) && (t.updateProgress(), t.updateActiveIndex(), t.updateSlidesClasses()); } else { for (var k = 0, $ = t.slidesSizesGrid[0], L = 0; L < l.length; L += L < s.slidesPerGroupSkip ? 1 : s.slidesPerGroup) { const I = L < s.slidesPerGroupSkip - 1 ? 1 : s.slidesPerGroup; void 0 !== l[L + I] ? p >= l[L] && p < l[L + I] && (k = L, $ = l[L + I] - l[L]) : p >= l[L] && (k = L, $ = l[l.length - 1] - l[l.length - 2]); } const D = (p - l[k]) / $; const O = k < s.slidesPerGroupSkip - 1 ? 1 : s.slidesPerGroup; if (u > s.longSwipesMs) { if (!s.longSwipes) return void t.slideTo(t.activeIndex); t.swipeDirection === 'next' && (D >= s.longSwipesRatio ? t.slideTo(k + O) : t.slideTo(k)), t.swipeDirection === 'prev' && (D > 1 - s.longSwipesRatio ? t.slideTo(k + O) : t.slideTo(k)); } else { if (!s.shortSwipes) return void t.slideTo(t.activeIndex); t.navigation && (h.target === t.navigation.nextEl || h.target === t.navigation.prevEl) ? h.target === t.navigation.nextEl ? t.slideTo(k + O) : t.slideTo(k) : (t.swipeDirection === 'next' && t.slideTo(k + O), t.swipeDirection === 'prev' && t.slideTo(k)); } } } function G() { const e = this.params; const t = this.el; if (!t || t.offsetWidth !== 0) { e.breakpoints && this.setBreakpoint(); const i = this.allowSlideNext; const s = this.allowSlidePrev; const a = this.snapGrid; this.allowSlideNext = !0, this.allowSlidePrev = !0, this.updateSize(), this.updateSlides(), this.updateSlidesClasses(), (e.slidesPerView === 'auto' || e.slidesPerView > 1) && this.isEnd && !this.params.centeredSlides ? this.slideTo(this.slides.length - 1, 0, !1, !0) : this.slideTo(this.activeIndex, 0, !1, !0), this.autoplay && this.autoplay.running && this.autoplay.paused && this.autoplay.run(), this.allowSlidePrev = s, this.allowSlideNext = i, this.params.watchOverflow && a !== this.snapGrid && this.checkOverflow(); } } function H(e) { this.allowClick || (this.params.preventClicks && e.preventDefault(), this.params.preventClicksPropagation && this.animating && (e.stopPropagation(), e.stopImmediatePropagation())); } function B() { const e = this.wrapperEl; const t = this.rtlTranslate; this.previousTranslate = this.translate, this.isHorizontal() ? this.translate = t ? e.scrollWidth - e.offsetWidth - e.scrollLeft : -e.scrollLeft : this.translate = -e.scrollTop, this.translate === -0 && (this.translate = 0), this.updateActiveIndex(), this.updateSlidesClasses(); const i = this.maxTranslate() - this.minTranslate(); (i === 0 ? 0 : (this.translate - this.minTranslate()) / i) !== this.progress && this.updateProgress(t ? -this.translate : this.translate), this.emit('setTranslate', this.translate, !1); } let N = !1; function X() {} const V = {
    init: !0, direction: 'horizontal', touchEventsTarget: 'container', initialSlide: 0, speed: 300, cssMode: !1, updateOnWindowResize: !0, preventInteractionOnTransition: !1, edgeSwipeDetection: !1, edgeSwipeThreshold: 20, freeMode: !1, freeModeMomentum: !0, freeModeMomentumRatio: 1, freeModeMomentumBounce: !0, freeModeMomentumBounceRatio: 1, freeModeMomentumVelocityRatio: 1, freeModeSticky: !1, freeModeMinimumVelocity: 0.02, autoHeight: !1, setWrapperSize: !1, virtualTranslate: !1, effect: 'slide', breakpoints: void 0, spaceBetween: 0, slidesPerView: 1, slidesPerColumn: 1, slidesPerColumnFill: 'column', slidesPerGroup: 1, slidesPerGroupSkip: 0, centeredSlides: !1, centeredSlidesBounds: !1, slidesOffsetBefore: 0, slidesOffsetAfter: 0, normalizeSlideIndex: !0, centerInsufficientSlides: !1, watchOverflow: !1, roundLengths: !1, touchRatio: 1, touchAngle: 45, simulateTouch: !0, shortSwipes: !0, longSwipes: !0, longSwipesRatio: 0.5, longSwipesMs: 300, followFinger: !0, allowTouchMove: !0, threshold: 0, touchMoveStopPropagation: !1, touchStartPreventDefault: !0, touchStartForcePreventDefault: !1, touchReleaseOnEdges: !1, uniqueNavElements: !0, resistance: !0, resistanceRatio: 0.85, watchSlidesProgress: !1, watchSlidesVisibility: !1, grabCursor: !1, preventClicks: !0, preventClicksPropagation: !0, slideToClickedSlide: !1, preloadImages: !0, updateOnImagesReady: !0, loop: !1, loopAdditionalSlides: 0, loopedSlides: null, loopFillGroupWithBlank: !1, allowSlidePrev: !0, allowSlideNext: !0, swipeHandler: null, noSwiping: !0, noSwipingClass: 'swiper-no-swiping', noSwipingSelector: null, passiveListeners: !0, containerModifierClass: 'swiper-container-', slideClass: 'swiper-slide', slideBlankClass: 'swiper-slide-invisible-blank', slideActiveClass: 'swiper-slide-active', slideDuplicateActiveClass: 'swiper-slide-duplicate-active', slideVisibleClass: 'swiper-slide-visible', slideDuplicateClass: 'swiper-slide-duplicate', slideNextClass: 'swiper-slide-next', slideDuplicateNextClass: 'swiper-slide-duplicate-next', slidePrevClass: 'swiper-slide-prev', slideDuplicatePrevClass: 'swiper-slide-duplicate-prev', wrapperClass: 'swiper-wrapper', runCallbacksOnInit: !0,
  }; const Y = {
    update: h, translate: p, transition: c, slide: u, loop: v, grabCursor: f, manipulation: L, events: { attachEvents() { const t = this.params; const i = this.touchEvents; const s = this.el; const a = this.wrapperEl; this.onTouchStart = D.bind(this), this.onTouchMove = O.bind(this), this.onTouchEnd = A.bind(this), t.cssMode && (this.onScroll = B.bind(this)), this.onClick = H.bind(this); const r = !!t.nested; if (!o.touch && o.pointerEvents)s.addEventListener(i.start, this.onTouchStart, !1), e.addEventListener(i.move, this.onTouchMove, r), e.addEventListener(i.end, this.onTouchEnd, !1); else { if (o.touch) { const n = !(i.start !== 'touchstart' || !o.passiveListener || !t.passiveListeners) && { passive: !0, capture: !1 }; s.addEventListener(i.start, this.onTouchStart, n), s.addEventListener(i.move, this.onTouchMove, o.passiveListener ? { passive: !1, capture: r } : r), s.addEventListener(i.end, this.onTouchEnd, n), i.cancel && s.addEventListener(i.cancel, this.onTouchEnd, n), N || (e.addEventListener('touchstart', X), N = !0); }(t.simulateTouch && !I.ios && !I.android || t.simulateTouch && !o.touch && I.ios) && (s.addEventListener('mousedown', this.onTouchStart, !1), e.addEventListener('mousemove', this.onTouchMove, r), e.addEventListener('mouseup', this.onTouchEnd, !1)); }(t.preventClicks || t.preventClicksPropagation) && s.addEventListener('click', this.onClick, !0), t.cssMode && a.addEventListener('scroll', this.onScroll), t.updateOnWindowResize ? this.on(I.ios || I.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', G, !0) : this.on('observerUpdate', G, !0); }, detachEvents() { const t = this.params; const i = this.touchEvents; const s = this.el; const a = this.wrapperEl; const r = !!t.nested; if (!o.touch && o.pointerEvents)s.removeEventListener(i.start, this.onTouchStart, !1), e.removeEventListener(i.move, this.onTouchMove, r), e.removeEventListener(i.end, this.onTouchEnd, !1); else { if (o.touch) { const n = !(i.start !== 'onTouchStart' || !o.passiveListener || !t.passiveListeners) && { passive: !0, capture: !1 }; s.removeEventListener(i.start, this.onTouchStart, n), s.removeEventListener(i.move, this.onTouchMove, r), s.removeEventListener(i.end, this.onTouchEnd, n), i.cancel && s.removeEventListener(i.cancel, this.onTouchEnd, n); }(t.simulateTouch && !I.ios && !I.android || t.simulateTouch && !o.touch && I.ios) && (s.removeEventListener('mousedown', this.onTouchStart, !1), e.removeEventListener('mousemove', this.onTouchMove, r), e.removeEventListener('mouseup', this.onTouchEnd, !1)); }(t.preventClicks || t.preventClicksPropagation) && s.removeEventListener('click', this.onClick, !0), t.cssMode && a.removeEventListener('scroll', this.onScroll), this.off(I.ios || I.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', G); } }, breakpoints: { setBreakpoint() { const e = this.activeIndex; const t = this.initialized; let i = this.loopedSlides; void 0 === i && (i = 0); const s = this.params; const a = this.$el; const r = s.breakpoints; if (r && (!r || Object.keys(r).length !== 0)) { const o = this.getBreakpoint(r); if (o && this.currentBreakpoint !== o) { const l = o in r ? r[o] : void 0; l && ['slidesPerView', 'spaceBetween', 'slidesPerGroup', 'slidesPerGroupSkip', 'slidesPerColumn'].forEach(((e) => { const t = l[e]; void 0 !== t && (l[e] = e !== 'slidesPerView' || t !== 'AUTO' && t !== 'auto' ? e === 'slidesPerView' ? parseFloat(t) : parseInt(t, 10) : 'auto'); })); const d = l || this.originalParams; const h = s.slidesPerColumn > 1; const p = d.slidesPerColumn > 1; h && !p ? a.removeClass(`${s.containerModifierClass}multirow ${s.containerModifierClass}multirow-column`) : !h && p && (a.addClass(`${s.containerModifierClass}multirow`), d.slidesPerColumnFill === 'column' && a.addClass(`${s.containerModifierClass}multirow-column`)); const c = d.direction && d.direction !== s.direction; const u = s.loop && (d.slidesPerView !== s.slidesPerView || c); c && t && this.changeDirection(), n.extend(this.params, d), n.extend(this, { allowTouchMove: this.params.allowTouchMove, allowSlideNext: this.params.allowSlideNext, allowSlidePrev: this.params.allowSlidePrev }), this.currentBreakpoint = o, u && t && (this.loopDestroy(), this.loopCreate(), this.updateSlides(), this.slideTo(e - i + this.loopedSlides, 0, !1)), this.emit('breakpoint', d); } } }, getBreakpoint(e) { if (e) { let i = !1; const s = Object.keys(e).map(((e) => { if (typeof e === 'string' && e.indexOf('@') === 0) { const i = parseFloat(e.substr(1)); return { value: t.innerHeight * i, point: e }; } return { value: e, point: e }; })); s.sort(((e, t) => parseInt(e.value, 10) - parseInt(t.value, 10))); for (let a = 0; a < s.length; a += 1) { const r = s[a]; const n = r.point; r.value <= t.innerWidth && (i = n); } return i || 'max'; } } }, checkOverflow: { checkOverflow() { const e = this.params; const t = this.isLocked; const i = this.slides.length > 0 && e.slidesOffsetBefore + e.spaceBetween * (this.slides.length - 1) + this.slides[0].offsetWidth * this.slides.length; e.slidesOffsetBefore && e.slidesOffsetAfter && i ? this.isLocked = i <= this.size : this.isLocked = this.snapGrid.length === 1, this.allowSlideNext = !this.isLocked, this.allowSlidePrev = !this.isLocked, t !== this.isLocked && this.emit(this.isLocked ? 'lock' : 'unlock'), t && t !== this.isLocked && (this.isEnd = !1, this.navigation.update()); } }, classes: { addClasses() { const e = this.classNames; const t = this.params; const i = this.rtl; const s = this.$el; const a = []; a.push('initialized'), a.push(t.direction), t.freeMode && a.push('free-mode'), t.autoHeight && a.push('autoheight'), i && a.push('rtl'), t.slidesPerColumn > 1 && (a.push('multirow'), t.slidesPerColumnFill === 'column' && a.push('multirow-column')), I.android && a.push('android'), I.ios && a.push('ios'), t.cssMode && a.push('css-mode'), a.forEach(((i) => { e.push(t.containerModifierClass + i); })), s.addClass(e.join(' ')); }, removeClasses() { const e = this.$el; const t = this.classNames; e.removeClass(t.join(' ')); } }, images: { loadImage(e, i, s, a, r, n) { let o; function l() { n && n(); }e.complete && r ? l() : i ? ((o = new t.Image()).onload = l, o.onerror = l, a && (o.sizes = a), s && (o.srcset = s), i && (o.src = i)) : l(); }, preloadImages() { const e = this; function t() { e != null && e && !e.destroyed && (void 0 !== e.imagesLoaded && (e.imagesLoaded += 1), e.imagesLoaded === e.imagesToLoad.length && (e.params.updateOnImagesReady && e.update(), e.emit('imagesReady'))); }e.imagesToLoad = e.$el.find('img'); for (let i = 0; i < e.imagesToLoad.length; i += 1) { const s = e.imagesToLoad[i]; e.loadImage(s, s.currentSrc || s.getAttribute('src'), s.srcset || s.getAttribute('srcset'), s.sizes || s.getAttribute('sizes'), !0, t); } } },
  }; const F = {}; const W = (function (e) {
    function t() {
      for (var i, a, r, l = [], d = arguments.length; d--;)l[d] = arguments[d]; l.length === 1 && l[0].constructor && l[0].constructor === Object ? r = l[0] : (a = (i = l)[0], r = i[1]), r || (r = {}), r = n.extend({}, r), a && !r.el && (r.el = a), e.call(this, r), Object.keys(Y).forEach(((e) => { Object.keys(Y[e]).forEach(((i) => { t.prototype[i] || (t.prototype[i] = Y[e][i]); })); })); const h = this; void 0 === h.modules && (h.modules = {}), Object.keys(h.modules).forEach(((e) => { const t = h.modules[e]; if (t.params) { const i = Object.keys(t.params)[0]; const s = t.params[i]; if (typeof s !== 'object' || s === null) return; if (!(i in r) || !('enabled' in s)) return; !0 === r[i] && (r[i] = { enabled: !0 }), typeof r[i] !== 'object' || 'enabled' in r[i] || (r[i].enabled = !0), r[i] || (r[i] = { enabled: !1 }); } })); const p = n.extend({}, V); h.useModulesParams(p), h.params = n.extend({}, p, F, r), h.originalParams = n.extend({}, h.params), h.passedParams = n.extend({}, r), h.$ = s; const c = s(h.params.el); if (a = c[0]) {
        if (c.length > 1) { const u = []; return c.each(((e, i) => { const s = n.extend({}, r, { el: i }); u.push(new t(s)); })), u; } let v; let f; let m; return a.swiper = h, c.data('swiper', h), a && a.shadowRoot && a.shadowRoot.querySelector ? (v = s(a.shadowRoot.querySelector(`.${h.params.wrapperClass}`))).children = function (e) { return c.children(e); } : v = c.children(`.${h.params.wrapperClass}`), n.extend(h, {
          $el: c,
          el: a,
          $wrapperEl: v,
          wrapperEl: v[0],
          classNames: [],
          slides: s(),
          slidesGrid: [],
          snapGrid: [],
          slidesSizesGrid: [],
          isHorizontal() { return h.params.direction === 'horizontal'; },
          isVertical() { return h.params.direction === 'vertical'; },
          rtl: a.dir.toLowerCase() === 'rtl' || c.css('direction') === 'rtl',
          rtlTranslate: h.params.direction === 'horizontal' && (a.dir.toLowerCase() === 'rtl' || c.css('direction') === 'rtl'),
          wrongRTL: v.css('display') === '-webkit-box',
          activeIndex: 0,
          realIndex: 0,
          isBeginning: !0,
          isEnd: !1,
          translate: 0,
          previousTranslate: 0,
          progress: 0,
          velocity: 0,
          animating: !1,
          allowSlideNext: h.params.allowSlideNext,
          allowSlidePrev: h.params.allowSlidePrev,
          touchEvents: (f = ['touchstart', 'touchmove', 'touchend', 'touchcancel'], m = ['mousedown', 'mousemove', 'mouseup'], o.pointerEvents && (m = ['pointerdown', 'pointermove', 'pointerup']), h.touchEventsTouch = {
            start: f[0], move: f[1], end: f[2], cancel: f[3],
          }, h.touchEventsDesktop = { start: m[0], move: m[1], end: m[2] }, o.touch || !h.params.simulateTouch ? h.touchEventsTouch : h.touchEventsDesktop),
          touchEventsData: {
            isTouched: void 0, isMoved: void 0, allowTouchCallbacks: void 0, touchStartTime: void 0, isScrolling: void 0, currentTranslate: void 0, startTranslate: void 0, allowThresholdMove: void 0, formElements: 'input, select, option, textarea, button, video, label', lastClickTime: n.now(), clickTimeout: void 0, velocities: [], allowMomentumBounce: void 0, isTouchEvent: void 0, startMoving: void 0,
          },
          allowClick: !0,
          allowTouchMove: h.params.allowTouchMove,
          touches: {
            startX: 0, startY: 0, currentX: 0, currentY: 0, diff: 0,
          },
          imagesToLoad: [],
          imagesLoaded: 0,
        }), h.useModules(), h.params.init && h.init(), h;
      }
    }e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t; const i = {
      extendedDefaults: { configurable: !0 }, defaults: { configurable: !0 }, Class: { configurable: !0 }, $: { configurable: !0 },
    }; return t.prototype.slidesPerViewDynamic = function () { const e = this.params; const t = this.slides; const i = this.slidesGrid; const s = this.size; const a = this.activeIndex; let r = 1; if (e.centeredSlides) { for (var n, o = t[a].swiperSlideSize, l = a + 1; l < t.length; l += 1)t[l] && !n && (r += 1, (o += t[l].swiperSlideSize) > s && (n = !0)); for (let d = a - 1; d >= 0; d -= 1)t[d] && !n && (r += 1, (o += t[d].swiperSlideSize) > s && (n = !0)); } else for (let h = a + 1; h < t.length; h += 1)i[h] - i[a] < s && (r += 1); return r; }, t.prototype.update = function () { const e = this; if (e && !e.destroyed) { const t = e.snapGrid; const i = e.params; i.breakpoints && e.setBreakpoint(), e.updateSize(), e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(), e.params.freeMode ? (s(), e.params.autoHeight && e.updateAutoHeight()) : ((e.params.slidesPerView === 'auto' || e.params.slidesPerView > 1) && e.isEnd && !e.params.centeredSlides ? e.slideTo(e.slides.length - 1, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0)) || s(), i.watchOverflow && t !== e.snapGrid && e.checkOverflow(), e.emit('update'); } function s() { const t = e.rtlTranslate ? -1 * e.translate : e.translate; const i = Math.min(Math.max(t, e.maxTranslate()), e.minTranslate()); e.setTranslate(i), e.updateActiveIndex(), e.updateSlidesClasses(); } }, t.prototype.changeDirection = function (e, t) { void 0 === t && (t = !0); const i = this.params.direction; return e || (e = i === 'horizontal' ? 'vertical' : 'horizontal'), e === i || e !== 'horizontal' && e !== 'vertical' || (this.$el.removeClass(`${this.params.containerModifierClass}${i}`).addClass(`${this.params.containerModifierClass}${e}`), this.params.direction = e, this.slides.each(((t, i) => { e === 'vertical' ? i.style.width = '' : i.style.height = ''; })), this.emit('changeDirection'), t && this.update()), this; }, t.prototype.init = function () { this.initialized || (this.emit('beforeInit'), this.params.breakpoints && this.setBreakpoint(), this.addClasses(), this.params.loop && this.loopCreate(), this.updateSize(), this.updateSlides(), this.params.watchOverflow && this.checkOverflow(), this.params.grabCursor && this.setGrabCursor(), this.params.preloadImages && this.preloadImages(), this.params.loop ? this.slideTo(this.params.initialSlide + this.loopedSlides, 0, this.params.runCallbacksOnInit) : this.slideTo(this.params.initialSlide, 0, this.params.runCallbacksOnInit), this.attachEvents(), this.initialized = !0, this.emit('init')); }, t.prototype.destroy = function (e, t) { void 0 === e && (e = !0), void 0 === t && (t = !0); const i = this; const s = i.params; const a = i.$el; const r = i.$wrapperEl; const o = i.slides; return void 0 === i.params || i.destroyed || (i.emit('beforeDestroy'), i.initialized = !1, i.detachEvents(), s.loop && i.loopDestroy(), t && (i.removeClasses(), a.removeAttr('style'), r.removeAttr('style'), o && o.length && o.removeClass([s.slideVisibleClass, s.slideActiveClass, s.slideNextClass, s.slidePrevClass].join(' ')).removeAttr('style').removeAttr('data-swiper-slide-index')), i.emit('destroy'), Object.keys(i.eventsListeners).forEach(((e) => { i.off(e); })), !1 !== e && (i.$el[0].swiper = null, i.$el.data('swiper', null), n.deleteProps(i)), i.destroyed = !0), null; }, t.extendDefaults = function (e) { n.extend(F, e); }, i.extendedDefaults.get = function () { return F; }, i.defaults.get = function () { return V; }, i.Class.get = function () { return e; }, i.$.get = function () { return s; }, Object.defineProperties(t, i), t;
  }(l)); const R = { name: 'device', proto: { device: I }, static: { device: I } }; const q = { name: 'support', proto: { support: o }, static: { support: o } }; const j = { isEdge: !!t.navigator.userAgent.match(/Edge/g), isSafari: (function () { const e = t.navigator.userAgent.toLowerCase(); return e.indexOf('safari') >= 0 && e.indexOf('chrome') < 0 && e.indexOf('android') < 0; }()), isUiWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(t.navigator.userAgent) }; const K = { name: 'browser', proto: { browser: j }, static: { browser: j } }; const U = { name: 'resize', create() { const e = this; n.extend(e, { resize: { resizeHandler() { e && !e.destroyed && e.initialized && (e.emit('beforeResize'), e.emit('resize')); }, orientationChangeHandler() { e && !e.destroyed && e.initialized && e.emit('orientationchange'); } } }); }, on: { init() { t.addEventListener('resize', this.resize.resizeHandler), t.addEventListener('orientationchange', this.resize.orientationChangeHandler); }, destroy() { t.removeEventListener('resize', this.resize.resizeHandler), t.removeEventListener('orientationchange', this.resize.orientationChangeHandler); } } }; var _ = {
    func: t.MutationObserver || t.WebkitMutationObserver, attach(e, i) { void 0 === i && (i = {}); const s = this; const a = new (0, _.func)((((e) => { if (e.length !== 1) { const i = function () { s.emit('observerUpdate', e[0]); }; t.requestAnimationFrame ? t.requestAnimationFrame(i) : t.setTimeout(i, 0); } else s.emit('observerUpdate', e[0]); }))); a.observe(e, { attributes: void 0 === i.attributes || i.attributes, childList: void 0 === i.childList || i.childList, characterData: void 0 === i.characterData || i.characterData }), s.observer.observers.push(a); }, init() { if (o.observer && this.params.observer) { if (this.params.observeParents) for (let e = this.$el.parents(), t = 0; t < e.length; t += 1) this.observer.attach(e[t]); this.observer.attach(this.$el[0], { childList: this.params.observeSlideChildren }), this.observer.attach(this.$wrapperEl[0], { attributes: !1 }); } }, destroy() { this.observer.observers.forEach(((e) => { e.disconnect(); })), this.observer.observers = []; },
  }; const Z = {
    name: 'observer',
    params: { observer: !1, observeParents: !1, observeSlideChildren: !1 },
    create() {
      n.extend(this, {
        observer: {
          init: _.init.bind(this), attach: _.attach.bind(this), destroy: _.destroy.bind(this), observers: [],
        },
      });
    },
    on: { init() { this.observer.init(); }, destroy() { this.observer.destroy(); } },
  }; const Q = {
    update(e) {
      const t = this; const i = t.params; const s = i.slidesPerView; const a = i.slidesPerGroup; const r = i.centeredSlides; const o = t.params.virtual; const l = o.addSlidesBefore; const d = o.addSlidesAfter; const h = t.virtual; const p = h.from; const c = h.to; const u = h.slides; const v = h.slidesGrid; const f = h.renderSlide; const m = h.offset; t.updateActiveIndex(); let g; let b; let w; const y = t.activeIndex || 0; g = t.rtlTranslate ? 'right' : t.isHorizontal() ? 'left' : 'top', r ? (b = Math.floor(s / 2) + a + l, w = Math.floor(s / 2) + a + d) : (b = s + (a - 1) + l, w = a + d); const x = Math.max((y || 0) - w, 0); const T = Math.min((y || 0) + b, u.length - 1); const E = (t.slidesGrid[x] || 0) - (t.slidesGrid[0] || 0); function S() { t.updateSlides(), t.updateProgress(), t.updateSlidesClasses(), t.lazy && t.params.lazy.enabled && t.lazy.load(); } if (n.extend(t.virtual, {
        from: x, to: T, offset: E, slidesGrid: t.slidesGrid,
      }), p === x && c === T && !e) return t.slidesGrid !== v && E !== m && t.slides.css(g, `${E}px`), void t.updateProgress(); if (t.params.virtual.renderExternal) {
        return t.params.virtual.renderExternal.call(t, {
          offset: E, from: x, to: T, slides: (function () { for (var e = [], t = x; t <= T; t += 1)e.push(u[t]); return e; }()),
        }), void S();
      } const C = []; const M = []; if (e)t.$wrapperEl.find(`.${t.params.slideClass}`).remove(); else for (let P = p; P <= c; P += 1)(P < x || P > T) && t.$wrapperEl.find(`.${t.params.slideClass}[data-swiper-slide-index="${P}"]`).remove(); for (let z = 0; z < u.length; z += 1)z >= x && z <= T && (void 0 === c || e ? M.push(z) : (z > c && M.push(z), z < p && C.push(z))); M.forEach(((e) => { t.$wrapperEl.append(f(u[e], e)); })), C.sort(((e, t) => t - e)).forEach(((e) => { t.$wrapperEl.prepend(f(u[e], e)); })), t.$wrapperEl.children('.swiper-slide').css(g, `${E}px`), S();
    },
    renderSlide(e, t) { const i = this.params.virtual; if (i.cache && this.virtual.cache[t]) return this.virtual.cache[t]; const a = i.renderSlide ? s(i.renderSlide.call(this, e, t)) : s(`<div class="${this.params.slideClass}" data-swiper-slide-index="${t}">${e}</div>`); return a.attr('data-swiper-slide-index') || a.attr('data-swiper-slide-index', t), i.cache && (this.virtual.cache[t] = a), a; },
    appendSlide(e) { if (typeof e === 'object' && 'length' in e) for (let t = 0; t < e.length; t += 1)e[t] && this.virtual.slides.push(e[t]); else this.virtual.slides.push(e); this.virtual.update(!0); },
    prependSlide(e) { const t = this.activeIndex; let i = t + 1; let s = 1; if (Array.isArray(e)) { for (let a = 0; a < e.length; a += 1)e[a] && this.virtual.slides.unshift(e[a]); i = t + e.length, s = e.length; } else this.virtual.slides.unshift(e); if (this.params.virtual.cache) { const r = this.virtual.cache; const n = {}; Object.keys(r).forEach(((e) => { const t = r[e]; const i = t.attr('data-swiper-slide-index'); i && t.attr('data-swiper-slide-index', parseInt(i, 10) + 1), n[parseInt(e, 10) + s] = t; })), this.virtual.cache = n; } this.virtual.update(!0), this.slideTo(i, 0); },
    removeSlide(e) { if (e != null) { let t = this.activeIndex; if (Array.isArray(e)) for (let i = e.length - 1; i >= 0; i -= 1) this.virtual.slides.splice(e[i], 1), this.params.virtual.cache && delete this.virtual.cache[e[i]], e[i] < t && (t -= 1), t = Math.max(t, 0); else this.virtual.slides.splice(e, 1), this.params.virtual.cache && delete this.virtual.cache[e], e < t && (t -= 1), t = Math.max(t, 0); this.virtual.update(!0), this.slideTo(t, 0); } },
    removeAllSlides() { this.virtual.slides = [], this.params.virtual.cache && (this.virtual.cache = {}), this.virtual.update(!0), this.slideTo(0, 0); },
  }; const J = {
    name: 'virtual',
    params: {
      virtual: {
        enabled: !1, slides: [], cache: !0, renderSlide: null, renderExternal: null, addSlidesBefore: 0, addSlidesAfter: 0,
      },
    },
    create() {
      n.extend(this, {
        virtual: {
          update: Q.update.bind(this), appendSlide: Q.appendSlide.bind(this), prependSlide: Q.prependSlide.bind(this), removeSlide: Q.removeSlide.bind(this), removeAllSlides: Q.removeAllSlides.bind(this), renderSlide: Q.renderSlide.bind(this), slides: this.params.virtual.slides, cache: {},
        },
      });
    },
    on: { beforeInit() { if (this.params.virtual.enabled) { this.classNames.push(`${this.params.containerModifierClass}virtual`); const e = { watchSlidesProgress: !0 }; n.extend(this.params, e), n.extend(this.originalParams, e), this.params.initialSlide || this.virtual.update(); } }, setTranslate() { this.params.virtual.enabled && this.virtual.update(); } },
  }; const ee = { handle(i) { const s = this.rtlTranslate; let a = i; a.originalEvent && (a = a.originalEvent); const r = a.keyCode || a.charCode; if (!this.allowSlideNext && (this.isHorizontal() && r === 39 || this.isVertical() && r === 40 || r === 34)) return !1; if (!this.allowSlidePrev && (this.isHorizontal() && r === 37 || this.isVertical() && r === 38 || r === 33)) return !1; if (!(a.shiftKey || a.altKey || a.ctrlKey || a.metaKey || e.activeElement && e.activeElement.nodeName && (e.activeElement.nodeName.toLowerCase() === 'input' || e.activeElement.nodeName.toLowerCase() === 'textarea'))) { if (this.params.keyboard.onlyInViewport && (r === 33 || r === 34 || r === 37 || r === 39 || r === 38 || r === 40)) { let n = !1; if (this.$el.parents(`.${this.params.slideClass}`).length > 0 && this.$el.parents(`.${this.params.slideActiveClass}`).length === 0) return; const o = t.innerWidth; const l = t.innerHeight; const d = this.$el.offset(); s && (d.left -= this.$el[0].scrollLeft); for (let h = [[d.left, d.top], [d.left + this.width, d.top], [d.left, d.top + this.height], [d.left + this.width, d.top + this.height]], p = 0; p < h.length; p += 1) { const c = h[p]; c[0] >= 0 && c[0] <= o && c[1] >= 0 && c[1] <= l && (n = !0); } if (!n) return; } this.isHorizontal() ? (r !== 33 && r !== 34 && r !== 37 && r !== 39 || (a.preventDefault ? a.preventDefault() : a.returnValue = !1), (r !== 34 && r !== 39 || s) && (r !== 33 && r !== 37 || !s) || this.slideNext(), (r !== 33 && r !== 37 || s) && (r !== 34 && r !== 39 || !s) || this.slidePrev()) : (r !== 33 && r !== 34 && r !== 38 && r !== 40 || (a.preventDefault ? a.preventDefault() : a.returnValue = !1), r !== 34 && r !== 40 || this.slideNext(), r !== 33 && r !== 38 || this.slidePrev()), this.emit('keyPress', r); } }, enable() { this.keyboard.enabled || (s(e).on('keydown', this.keyboard.handle), this.keyboard.enabled = !0); }, disable() { this.keyboard.enabled && (s(e).off('keydown', this.keyboard.handle), this.keyboard.enabled = !1); } }; const te = {
    name: 'keyboard',
    params: { keyboard: { enabled: !1, onlyInViewport: !0 } },
    create() {
      n.extend(this, {
        keyboard: {
          enabled: !1, enable: ee.enable.bind(this), disable: ee.disable.bind(this), handle: ee.handle.bind(this),
        },
      });
    },
    on: { init() { this.params.keyboard.enabled && this.keyboard.enable(); }, destroy() { this.keyboard.enabled && this.keyboard.disable(); } },
  }; var ie = {
    lastScrollTime: n.now(),
    lastEventBeforeSnap: void 0,
    recentWheelEvents: [],
    event() { return t.navigator.userAgent.indexOf('firefox') > -1 ? 'DOMMouseScroll' : (function () { let t = 'onwheel' in e; if (!t) { const i = e.createElement('div'); i.setAttribute('onwheel', 'return;'), t = typeof i.onwheel === 'function'; } return !t && e.implementation && e.implementation.hasFeature && !0 !== e.implementation.hasFeature('', '') && (t = e.implementation.hasFeature('Events.wheel', '3.0')), t; }()) ? 'wheel' : 'mousewheel'; },
    normalize(e) {
      let t = 0; let i = 0; let s = 0; let a = 0; return 'detail' in e && (i = e.detail), 'wheelDelta' in e && (i = -e.wheelDelta / 120), 'wheelDeltaY' in e && (i = -e.wheelDeltaY / 120), 'wheelDeltaX' in e && (t = -e.wheelDeltaX / 120), 'axis' in e && e.axis === e.HORIZONTAL_AXIS && (t = i, i = 0), s = 10 * t, a = 10 * i, 'deltaY' in e && (a = e.deltaY), 'deltaX' in e && (s = e.deltaX), e.shiftKey && !s && (s = a, a = 0), (s || a) && e.deltaMode && (e.deltaMode === 1 ? (s *= 40, a *= 40) : (s *= 800, a *= 800)), s && !t && (t = s < 1 ? -1 : 1), a && !i && (i = a < 1 ? -1 : 1), {
        spinX: t, spinY: i, pixelX: s, pixelY: a,
      };
    },
    handleMouseEnter() { this.mouseEntered = !0; },
    handleMouseLeave() { this.mouseEntered = !1; },
    handle(e) {
      let t = e; const i = this; const a = i.params.mousewheel; i.params.cssMode && t.preventDefault(); let r = i.$el; if (i.params.mousewheel.eventsTarged !== 'container' && (r = s(i.params.mousewheel.eventsTarged)), !i.mouseEntered && !r[0].contains(t.target) && !a.releaseOnEdges) return !0; t.originalEvent && (t = t.originalEvent); let o = 0; const l = i.rtlTranslate ? -1 : 1; const d = ie.normalize(t); if (a.forceToAxis) if (i.isHorizontal()) { if (!(Math.abs(d.pixelX) > Math.abs(d.pixelY))) return !0; o = d.pixelX * l; } else { if (!(Math.abs(d.pixelY) > Math.abs(d.pixelX))) return !0; o = d.pixelY; } else o = Math.abs(d.pixelX) > Math.abs(d.pixelY) ? -d.pixelX * l : -d.pixelY; if (o === 0) return !0; if (a.invert && (o = -o), i.params.freeMode) { const h = { time: n.now(), delta: Math.abs(o), direction: Math.sign(o) }; const p = i.mousewheel.lastEventBeforeSnap; const c = p && h.time < p.time + 500 && h.delta <= p.delta && h.direction === p.direction; if (!c) { i.mousewheel.lastEventBeforeSnap = void 0, i.params.loop && i.loopFix(); let u = i.getTranslate() + o * a.sensitivity; const v = i.isBeginning; const f = i.isEnd; if (u >= i.minTranslate() && (u = i.minTranslate()), u <= i.maxTranslate() && (u = i.maxTranslate()), i.setTransition(0), i.setTranslate(u), i.updateProgress(), i.updateActiveIndex(), i.updateSlidesClasses(), (!v && i.isBeginning || !f && i.isEnd) && i.updateSlidesClasses(), i.params.freeModeSticky) { clearTimeout(i.mousewheel.timeout), i.mousewheel.timeout = void 0; const m = i.mousewheel.recentWheelEvents; m.length >= 15 && m.shift(); const g = m.length ? m[m.length - 1] : void 0; const b = m[0]; if (m.push(h), g && (h.delta > g.delta || h.direction !== g.direction))m.splice(0); else if (m.length >= 15 && h.time - b.time < 500 && b.delta - h.delta >= 1 && h.delta <= 6) { const w = o > 0 ? 0.8 : 0.2; i.mousewheel.lastEventBeforeSnap = h, m.splice(0), i.mousewheel.timeout = n.nextTick((() => { i.slideToClosest(i.params.speed, !0, void 0, w); }), 0); }i.mousewheel.timeout || (i.mousewheel.timeout = n.nextTick((() => { i.mousewheel.lastEventBeforeSnap = h, m.splice(0), i.slideToClosest(i.params.speed, !0, void 0, 0.5); }), 500)); } if (c || i.emit('scroll', t), i.params.autoplay && i.params.autoplayDisableOnInteraction && i.autoplay.stop(), u === i.minTranslate() || u === i.maxTranslate()) return !0; } } else {
        const y = {
          time: n.now(), delta: Math.abs(o), direction: Math.sign(o), raw: e,
        }; const x = i.mousewheel.recentWheelEvents; x.length >= 2 && x.shift(); const T = x.length ? x[x.length - 1] : void 0; if (x.push(y), T ? (y.direction !== T.direction || y.delta > T.delta) && i.mousewheel.animateSlider(y) : i.mousewheel.animateSlider(y), i.mousewheel.releaseScroll(y)) return !0;
      } return t.preventDefault ? t.preventDefault() : t.returnValue = !1, !1;
    },
    animateSlider(e) { return e.delta >= 6 && n.now() - this.mousewheel.lastScrollTime < 60 || (e.direction < 0 ? this.isEnd && !this.params.loop || this.animating || (this.slideNext(), this.emit('scroll', e.raw)) : this.isBeginning && !this.params.loop || this.animating || (this.slidePrev(), this.emit('scroll', e.raw)), this.mousewheel.lastScrollTime = (new t.Date()).getTime(), !1); },
    releaseScroll(e) { const t = this.params.mousewheel; if (e.direction < 0) { if (this.isEnd && !this.params.loop && t.releaseOnEdges) return !0; } else if (this.isBeginning && !this.params.loop && t.releaseOnEdges) return !0; return !1; },
    enable() { const e = ie.event(); if (this.params.cssMode) return this.wrapperEl.removeEventListener(e, this.mousewheel.handle), !0; if (!e) return !1; if (this.mousewheel.enabled) return !1; let t = this.$el; return this.params.mousewheel.eventsTarged !== 'container' && (t = s(this.params.mousewheel.eventsTarged)), t.on('mouseenter', this.mousewheel.handleMouseEnter), t.on('mouseleave', this.mousewheel.handleMouseLeave), t.on(e, this.mousewheel.handle), this.mousewheel.enabled = !0, !0; },
    disable() { const e = ie.event(); if (this.params.cssMode) return this.wrapperEl.addEventListener(e, this.mousewheel.handle), !0; if (!e) return !1; if (!this.mousewheel.enabled) return !1; let t = this.$el; return this.params.mousewheel.eventsTarged !== 'container' && (t = s(this.params.mousewheel.eventsTarged)), t.off(e, this.mousewheel.handle), this.mousewheel.enabled = !1, !0; },
  }; const se = {
    update() { const e = this.params.navigation; if (!this.params.loop) { const t = this.navigation; const i = t.$nextEl; const s = t.$prevEl; s && s.length > 0 && (this.isBeginning ? s.addClass(e.disabledClass) : s.removeClass(e.disabledClass), s[this.params.watchOverflow && this.isLocked ? 'addClass' : 'removeClass'](e.lockClass)), i && i.length > 0 && (this.isEnd ? i.addClass(e.disabledClass) : i.removeClass(e.disabledClass), i[this.params.watchOverflow && this.isLocked ? 'addClass' : 'removeClass'](e.lockClass)); } },
    onPrevClick(e) { e.preventDefault(), this.isBeginning && !this.params.loop || this.slidePrev(); },
    onNextClick(e) { e.preventDefault(), this.isEnd && !this.params.loop || this.slideNext(); },
    init() {
      let e; let t; const i = this.params.navigation; (i.nextEl || i.prevEl) && (i.nextEl && (e = s(i.nextEl), this.params.uniqueNavElements && typeof i.nextEl === 'string' && e.length > 1 && this.$el.find(i.nextEl).length === 1 && (e = this.$el.find(i.nextEl))), i.prevEl && (t = s(i.prevEl), this.params.uniqueNavElements && typeof i.prevEl === 'string' && t.length > 1 && this.$el.find(i.prevEl).length === 1 && (t = this.$el.find(i.prevEl))), e && e.length > 0 && e.on('click', this.navigation.onNextClick), t && t.length > 0 && t.on('click', this.navigation.onPrevClick), n.extend(this.navigation, {
        $nextEl: e, nextEl: e && e[0], $prevEl: t, prevEl: t && t[0],
      }));
    },
    destroy() { const e = this.navigation; const t = e.$nextEl; const i = e.$prevEl; t && t.length && (t.off('click', this.navigation.onNextClick), t.removeClass(this.params.navigation.disabledClass)), i && i.length && (i.off('click', this.navigation.onPrevClick), i.removeClass(this.params.navigation.disabledClass)); },
  }; const ae = {
    update() { const e = this.rtl; const t = this.params.pagination; if (t.el && this.pagination.el && this.pagination.$el && this.pagination.$el.length !== 0) { let i; const a = this.virtual && this.params.virtual.enabled ? this.virtual.slides.length : this.slides.length; const r = this.pagination.$el; const n = this.params.loop ? Math.ceil((a - 2 * this.loopedSlides) / this.params.slidesPerGroup) : this.snapGrid.length; if (this.params.loop ? ((i = Math.ceil((this.activeIndex - this.loopedSlides) / this.params.slidesPerGroup)) > a - 1 - 2 * this.loopedSlides && (i -= a - 2 * this.loopedSlides), i > n - 1 && (i -= n), i < 0 && this.params.paginationType !== 'bullets' && (i = n + i)) : i = void 0 !== this.snapIndex ? this.snapIndex : this.activeIndex || 0, t.type === 'bullets' && this.pagination.bullets && this.pagination.bullets.length > 0) { let o; let l; let d; const h = this.pagination.bullets; if (t.dynamicBullets && (this.pagination.bulletSize = h.eq(0)[this.isHorizontal() ? 'outerWidth' : 'outerHeight'](!0), r.css(this.isHorizontal() ? 'width' : 'height', `${this.pagination.bulletSize * (t.dynamicMainBullets + 4)}px`), t.dynamicMainBullets > 1 && void 0 !== this.previousIndex && (this.pagination.dynamicBulletIndex += i - this.previousIndex, this.pagination.dynamicBulletIndex > t.dynamicMainBullets - 1 ? this.pagination.dynamicBulletIndex = t.dynamicMainBullets - 1 : this.pagination.dynamicBulletIndex < 0 && (this.pagination.dynamicBulletIndex = 0)), o = i - this.pagination.dynamicBulletIndex, d = ((l = o + (Math.min(h.length, t.dynamicMainBullets) - 1)) + o) / 2), h.removeClass(`${t.bulletActiveClass} ${t.bulletActiveClass}-next ${t.bulletActiveClass}-next-next ${t.bulletActiveClass}-prev ${t.bulletActiveClass}-prev-prev ${t.bulletActiveClass}-main`), r.length > 1)h.each(((e, a) => { const r = s(a); const n = r.index(); n === i && r.addClass(t.bulletActiveClass), t.dynamicBullets && (n >= o && n <= l && r.addClass(`${t.bulletActiveClass}-main`), n === o && r.prev().addClass(`${t.bulletActiveClass}-prev`).prev().addClass(`${t.bulletActiveClass}-prev-prev`), n === l && r.next().addClass(`${t.bulletActiveClass}-next`).next().addClass(`${t.bulletActiveClass}-next-next`)); })); else { const p = h.eq(i); const c = p.index(); if (p.addClass(t.bulletActiveClass), t.dynamicBullets) { for (var u = h.eq(o), v = h.eq(l), f = o; f <= l; f += 1)h.eq(f).addClass(`${t.bulletActiveClass}-main`); if (this.params.loop) if (c >= h.length - t.dynamicMainBullets) { for (let m = t.dynamicMainBullets; m >= 0; m -= 1)h.eq(h.length - m).addClass(`${t.bulletActiveClass}-main`); h.eq(h.length - t.dynamicMainBullets - 1).addClass(`${t.bulletActiveClass}-prev`); } else u.prev().addClass(`${t.bulletActiveClass}-prev`).prev().addClass(`${t.bulletActiveClass}-prev-prev`), v.next().addClass(`${t.bulletActiveClass}-next`).next().addClass(`${t.bulletActiveClass}-next-next`); else u.prev().addClass(`${t.bulletActiveClass}-prev`).prev().addClass(`${t.bulletActiveClass}-prev-prev`), v.next().addClass(`${t.bulletActiveClass}-next`).next().addClass(`${t.bulletActiveClass}-next-next`); } } if (t.dynamicBullets) { const g = Math.min(h.length, t.dynamicMainBullets + 4); const b = (this.pagination.bulletSize * g - this.pagination.bulletSize) / 2 - d * this.pagination.bulletSize; const w = e ? 'right' : 'left'; h.css(this.isHorizontal() ? w : 'top', `${b}px`); } } if (t.type === 'fraction' && (r.find(`.${t.currentClass}`).text(t.formatFractionCurrent(i + 1)), r.find(`.${t.totalClass}`).text(t.formatFractionTotal(n))), t.type === 'progressbar') { let y; y = t.progressbarOpposite ? this.isHorizontal() ? 'vertical' : 'horizontal' : this.isHorizontal() ? 'horizontal' : 'vertical'; const x = (i + 1) / n; let T = 1; let E = 1; y === 'horizontal' ? T = x : E = x, r.find(`.${t.progressbarFillClass}`).transform(`translate3d(0,0,0) scaleX(${T}) scaleY(${E})`).transition(this.params.speed); }t.type === 'custom' && t.renderCustom ? (r.html(t.renderCustom(this, i + 1, n)), this.emit('paginationRender', this, r[0])) : this.emit('paginationUpdate', this, r[0]), r[this.params.watchOverflow && this.isLocked ? 'addClass' : 'removeClass'](t.lockClass); } }, render() { const e = this.params.pagination; if (e.el && this.pagination.el && this.pagination.$el && this.pagination.$el.length !== 0) { const t = this.virtual && this.params.virtual.enabled ? this.virtual.slides.length : this.slides.length; const i = this.pagination.$el; let s = ''; if (e.type === 'bullets') { for (let a = this.params.loop ? Math.ceil((t - 2 * this.loopedSlides) / this.params.slidesPerGroup) : this.snapGrid.length, r = 0; r < a; r += 1)e.renderBullet ? s += e.renderBullet.call(this, r, e.bulletClass) : s += `<${e.bulletElement} class="${e.bulletClass}"></${e.bulletElement}>`; i.html(s), this.pagination.bullets = i.find(`.${e.bulletClass}`); }e.type === 'fraction' && (s = e.renderFraction ? e.renderFraction.call(this, e.currentClass, e.totalClass) : `<span class="${e.currentClass}"></span> / <span class="${e.totalClass}"></span>`, i.html(s)), e.type === 'progressbar' && (s = e.renderProgressbar ? e.renderProgressbar.call(this, e.progressbarFillClass) : `<span class="${e.progressbarFillClass}"></span>`, i.html(s)), e.type !== 'custom' && this.emit('paginationRender', this.pagination.$el[0]); } }, init() { const e = this; const t = e.params.pagination; if (t.el) { let i = s(t.el); i.length !== 0 && (e.params.uniqueNavElements && typeof t.el === 'string' && i.length > 1 && e.$el.find(t.el).length === 1 && (i = e.$el.find(t.el)), t.type === 'bullets' && t.clickable && i.addClass(t.clickableClass), i.addClass(t.modifierClass + t.type), t.type === 'bullets' && t.dynamicBullets && (i.addClass(`${t.modifierClass}${t.type}-dynamic`), e.pagination.dynamicBulletIndex = 0, t.dynamicMainBullets < 1 && (t.dynamicMainBullets = 1)), t.type === 'progressbar' && t.progressbarOpposite && i.addClass(t.progressbarOppositeClass), t.clickable && i.on('click', `.${t.bulletClass}`, (function (t) { t.preventDefault(); let i = s(this).index() * e.params.slidesPerGroup; e.params.loop && (i += e.loopedSlides), e.slideTo(i); })), n.extend(e.pagination, { $el: i, el: i[0] })); } }, destroy() { const e = this.params.pagination; if (e.el && this.pagination.el && this.pagination.$el && this.pagination.$el.length !== 0) { const t = this.pagination.$el; t.removeClass(e.hiddenClass), t.removeClass(e.modifierClass + e.type), this.pagination.bullets && this.pagination.bullets.removeClass(e.bulletActiveClass), e.clickable && t.off('click', `.${e.bulletClass}`); } },
  }; const re = {
    setTranslate() { if (this.params.scrollbar.el && this.scrollbar.el) { const e = this.scrollbar; const t = this.rtlTranslate; const i = this.progress; const s = e.dragSize; const a = e.trackSize; const r = e.$dragEl; const n = e.$el; const o = this.params.scrollbar; let l = s; let d = (a - s) * i; t ? (d = -d) > 0 ? (l = s - d, d = 0) : -d + s > a && (l = a + d) : d < 0 ? (l = s + d, d = 0) : d + s > a && (l = a - d), this.isHorizontal() ? (r.transform(`translate3d(${d}px, 0, 0)`), r[0].style.width = `${l}px`) : (r.transform(`translate3d(0px, ${d}px, 0)`), r[0].style.height = `${l}px`), o.hide && (clearTimeout(this.scrollbar.timeout), n[0].style.opacity = 1, this.scrollbar.timeout = setTimeout((() => { n[0].style.opacity = 0, n.transition(400); }), 1e3)); } },
    setTransition(e) { this.params.scrollbar.el && this.scrollbar.el && this.scrollbar.$dragEl.transition(e); },
    updateSize() {
      if (this.params.scrollbar.el && this.scrollbar.el) {
        const e = this.scrollbar; const t = e.$dragEl; const i = e.$el; t[0].style.width = '', t[0].style.height = ''; let s; const a = this.isHorizontal() ? i[0].offsetWidth : i[0].offsetHeight; const r = this.size / this.virtualSize; const o = r * (a / this.size); s = this.params.scrollbar.dragSize === 'auto' ? a * r : parseInt(this.params.scrollbar.dragSize, 10), this.isHorizontal() ? t[0].style.width = `${s}px` : t[0].style.height = `${s}px`, i[0].style.display = r >= 1 ? 'none' : '', this.params.scrollbar.hide && (i[0].style.opacity = 0), n.extend(e, {
          trackSize: a, divider: r, moveDivider: o, dragSize: s,
        }), e.$el[this.params.watchOverflow && this.isLocked ? 'addClass' : 'removeClass'](this.params.scrollbar.lockClass);
      }
    },
    getPointerPosition(e) { return this.isHorizontal() ? e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].clientX : e.clientX : e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].clientY : e.clientY; },
    setDragPosition(e) { let t; const i = this.scrollbar; const s = this.rtlTranslate; const a = i.$el; const r = i.dragSize; const n = i.trackSize; const o = i.dragStartPos; t = (i.getPointerPosition(e) - a.offset()[this.isHorizontal() ? 'left' : 'top'] - (o !== null ? o : r / 2)) / (n - r), t = Math.max(Math.min(t, 1), 0), s && (t = 1 - t); const l = this.minTranslate() + (this.maxTranslate() - this.minTranslate()) * t; this.updateProgress(l), this.setTranslate(l), this.updateActiveIndex(), this.updateSlidesClasses(); },
    onDragStart(e) { const t = this.params.scrollbar; const i = this.scrollbar; const s = this.$wrapperEl; const a = i.$el; const r = i.$dragEl; this.scrollbar.isTouched = !0, this.scrollbar.dragStartPos = e.target === r[0] || e.target === r ? i.getPointerPosition(e) - e.target.getBoundingClientRect()[this.isHorizontal() ? 'left' : 'top'] : null, e.preventDefault(), e.stopPropagation(), s.transition(100), r.transition(100), i.setDragPosition(e), clearTimeout(this.scrollbar.dragTimeout), a.transition(0), t.hide && a.css('opacity', 1), this.params.cssMode && this.$wrapperEl.css('scroll-snap-type', 'none'), this.emit('scrollbarDragStart', e); },
    onDragMove(e) { const t = this.scrollbar; const i = this.$wrapperEl; const s = t.$el; const a = t.$dragEl; this.scrollbar.isTouched && (e.preventDefault ? e.preventDefault() : e.returnValue = !1, t.setDragPosition(e), i.transition(0), s.transition(0), a.transition(0), this.emit('scrollbarDragMove', e)); },
    onDragEnd(e) { const t = this.params.scrollbar; const i = this.scrollbar; const s = this.$wrapperEl; const a = i.$el; this.scrollbar.isTouched && (this.scrollbar.isTouched = !1, this.params.cssMode && (this.$wrapperEl.css('scroll-snap-type', ''), s.transition('')), t.hide && (clearTimeout(this.scrollbar.dragTimeout), this.scrollbar.dragTimeout = n.nextTick((() => { a.css('opacity', 0), a.transition(400); }), 1e3)), this.emit('scrollbarDragEnd', e), t.snapOnRelease && this.slideToClosest()); },
    enableDraggable() { if (this.params.scrollbar.el) { const t = this.scrollbar; const i = this.touchEventsTouch; const s = this.touchEventsDesktop; const a = this.params; const r = t.$el[0]; const n = !(!o.passiveListener || !a.passiveListeners) && { passive: !1, capture: !1 }; const l = !(!o.passiveListener || !a.passiveListeners) && { passive: !0, capture: !1 }; o.touch ? (r.addEventListener(i.start, this.scrollbar.onDragStart, n), r.addEventListener(i.move, this.scrollbar.onDragMove, n), r.addEventListener(i.end, this.scrollbar.onDragEnd, l)) : (r.addEventListener(s.start, this.scrollbar.onDragStart, n), e.addEventListener(s.move, this.scrollbar.onDragMove, n), e.addEventListener(s.end, this.scrollbar.onDragEnd, l)); } },
    disableDraggable() { if (this.params.scrollbar.el) { const t = this.scrollbar; const i = this.touchEventsTouch; const s = this.touchEventsDesktop; const a = this.params; const r = t.$el[0]; const n = !(!o.passiveListener || !a.passiveListeners) && { passive: !1, capture: !1 }; const l = !(!o.passiveListener || !a.passiveListeners) && { passive: !0, capture: !1 }; o.touch ? (r.removeEventListener(i.start, this.scrollbar.onDragStart, n), r.removeEventListener(i.move, this.scrollbar.onDragMove, n), r.removeEventListener(i.end, this.scrollbar.onDragEnd, l)) : (r.removeEventListener(s.start, this.scrollbar.onDragStart, n), e.removeEventListener(s.move, this.scrollbar.onDragMove, n), e.removeEventListener(s.end, this.scrollbar.onDragEnd, l)); } },
    init() {
      if (this.params.scrollbar.el) {
        const e = this.scrollbar; const t = this.$el; const i = this.params.scrollbar; let a = s(i.el); this.params.uniqueNavElements && typeof i.el === 'string' && a.length > 1 && t.find(i.el).length === 1 && (a = t.find(i.el)); let r = a.find(`.${this.params.scrollbar.dragClass}`); r.length === 0 && (r = s(`<div class="${this.params.scrollbar.dragClass}"></div>`), a.append(r)), n.extend(e, {
          $el: a, el: a[0], $dragEl: r, dragEl: r[0],
        }), i.draggable && e.enableDraggable();
      }
    },
    destroy() { this.scrollbar.disableDraggable(); },
  }; const ne = { setTransform(e, t) { const i = this.rtl; const a = s(e); const r = i ? -1 : 1; const n = a.attr('data-swiper-parallax') || '0'; let o = a.attr('data-swiper-parallax-x'); let l = a.attr('data-swiper-parallax-y'); const d = a.attr('data-swiper-parallax-scale'); const h = a.attr('data-swiper-parallax-opacity'); if (o || l ? (o = o || '0', l = l || '0') : this.isHorizontal() ? (o = n, l = '0') : (l = n, o = '0'), o = o.indexOf('%') >= 0 ? `${parseInt(o, 10) * t * r}%` : `${o * t * r}px`, l = l.indexOf('%') >= 0 ? `${parseInt(l, 10) * t}%` : `${l * t}px`, h != null) { const p = h - (h - 1) * (1 - Math.abs(t)); a[0].style.opacity = p; } if (d == null)a.transform(`translate3d(${o}, ${l}, 0px)`); else { const c = d - (d - 1) * (1 - Math.abs(t)); a.transform(`translate3d(${o}, ${l}, 0px) scale(${c})`); } }, setTranslate() { const e = this; const t = e.$el; const i = e.slides; const a = e.progress; const r = e.snapGrid; t.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(((t, i) => { e.parallax.setTransform(i, a); })), i.each(((t, i) => { let n = i.progress; e.params.slidesPerGroup > 1 && e.params.slidesPerView !== 'auto' && (n += Math.ceil(t / 2) - a * (r.length - 1)), n = Math.min(Math.max(n, -1), 1), s(i).find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(((t, i) => { e.parallax.setTransform(i, n); })); })); }, setTransition(e) { void 0 === e && (e = this.params.speed); this.$el.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(((t, i) => { const a = s(i); let r = parseInt(a.attr('data-swiper-parallax-duration'), 10) || e; e === 0 && (r = 0), a.transition(r); })); } }; var oe = {
    getDistanceBetweenTouches(e) { if (e.targetTouches.length < 2) return 1; const t = e.targetTouches[0].pageX; const i = e.targetTouches[0].pageY; const s = e.targetTouches[1].pageX; const a = e.targetTouches[1].pageY; return Math.sqrt(Math.pow(s - t, 2) + Math.pow(a - i, 2)); }, onGestureStart(e) { const t = this.params.zoom; const i = this.zoom; const a = i.gesture; if (i.fakeGestureTouched = !1, i.fakeGestureMoved = !1, !o.gestures) { if (e.type !== 'touchstart' || e.type === 'touchstart' && e.targetTouches.length < 2) return; i.fakeGestureTouched = !0, a.scaleStart = oe.getDistanceBetweenTouches(e); }a.$slideEl && a.$slideEl.length || (a.$slideEl = s(e.target).closest(`.${this.params.slideClass}`), a.$slideEl.length === 0 && (a.$slideEl = this.slides.eq(this.activeIndex)), a.$imageEl = a.$slideEl.find('img, svg, canvas, picture, .swiper-zoom-target'), a.$imageWrapEl = a.$imageEl.parent(`.${t.containerClass}`), a.maxRatio = a.$imageWrapEl.attr('data-swiper-zoom') || t.maxRatio, a.$imageWrapEl.length !== 0) ? (a.$imageEl && a.$imageEl.transition(0), this.zoom.isScaling = !0) : a.$imageEl = void 0; }, onGestureChange(e) { const t = this.params.zoom; const i = this.zoom; const s = i.gesture; if (!o.gestures) { if (e.type !== 'touchmove' || e.type === 'touchmove' && e.targetTouches.length < 2) return; i.fakeGestureMoved = !0, s.scaleMove = oe.getDistanceBetweenTouches(e); }s.$imageEl && s.$imageEl.length !== 0 && (i.scale = o.gestures ? e.scale * i.currentScale : s.scaleMove / s.scaleStart * i.currentScale, i.scale > s.maxRatio && (i.scale = s.maxRatio - 1 + Math.pow(i.scale - s.maxRatio + 1, 0.5)), i.scale < t.minRatio && (i.scale = t.minRatio + 1 - Math.pow(t.minRatio - i.scale + 1, 0.5)), s.$imageEl.transform(`translate3d(0,0,0) scale(${i.scale})`)); }, onGestureEnd(e) { const t = this.params.zoom; const i = this.zoom; const s = i.gesture; if (!o.gestures) { if (!i.fakeGestureTouched || !i.fakeGestureMoved) return; if (e.type !== 'touchend' || e.type === 'touchend' && e.changedTouches.length < 2 && !I.android) return; i.fakeGestureTouched = !1, i.fakeGestureMoved = !1; }s.$imageEl && s.$imageEl.length !== 0 && (i.scale = Math.max(Math.min(i.scale, s.maxRatio), t.minRatio), s.$imageEl.transition(this.params.speed).transform(`translate3d(0,0,0) scale(${i.scale})`), i.currentScale = i.scale, i.isScaling = !1, i.scale === 1 && (s.$slideEl = void 0)); }, onTouchStart(e) { const t = this.zoom; const i = t.gesture; const s = t.image; i.$imageEl && i.$imageEl.length !== 0 && (s.isTouched || (I.android && e.preventDefault(), s.isTouched = !0, s.touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX, s.touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY)); }, onTouchMove(e) { const t = this.zoom; const i = t.gesture; const s = t.image; const a = t.velocity; if (i.$imageEl && i.$imageEl.length !== 0 && (this.allowClick = !1, s.isTouched && i.$slideEl)) { s.isMoved || (s.width = i.$imageEl[0].offsetWidth, s.height = i.$imageEl[0].offsetHeight, s.startX = n.getTranslate(i.$imageWrapEl[0], 'x') || 0, s.startY = n.getTranslate(i.$imageWrapEl[0], 'y') || 0, i.slideWidth = i.$slideEl[0].offsetWidth, i.slideHeight = i.$slideEl[0].offsetHeight, i.$imageWrapEl.transition(0), this.rtl && (s.startX = -s.startX, s.startY = -s.startY)); const r = s.width * t.scale; const o = s.height * t.scale; if (!(r < i.slideWidth && o < i.slideHeight)) { if (s.minX = Math.min(i.slideWidth / 2 - r / 2, 0), s.maxX = -s.minX, s.minY = Math.min(i.slideHeight / 2 - o / 2, 0), s.maxY = -s.minY, s.touchesCurrent.x = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX, s.touchesCurrent.y = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY, !s.isMoved && !t.isScaling) { if (this.isHorizontal() && (Math.floor(s.minX) === Math.floor(s.startX) && s.touchesCurrent.x < s.touchesStart.x || Math.floor(s.maxX) === Math.floor(s.startX) && s.touchesCurrent.x > s.touchesStart.x)) return void (s.isTouched = !1); if (!this.isHorizontal() && (Math.floor(s.minY) === Math.floor(s.startY) && s.touchesCurrent.y < s.touchesStart.y || Math.floor(s.maxY) === Math.floor(s.startY) && s.touchesCurrent.y > s.touchesStart.y)) return void (s.isTouched = !1); }e.preventDefault(), e.stopPropagation(), s.isMoved = !0, s.currentX = s.touchesCurrent.x - s.touchesStart.x + s.startX, s.currentY = s.touchesCurrent.y - s.touchesStart.y + s.startY, s.currentX < s.minX && (s.currentX = s.minX + 1 - Math.pow(s.minX - s.currentX + 1, 0.8)), s.currentX > s.maxX && (s.currentX = s.maxX - 1 + Math.pow(s.currentX - s.maxX + 1, 0.8)), s.currentY < s.minY && (s.currentY = s.minY + 1 - Math.pow(s.minY - s.currentY + 1, 0.8)), s.currentY > s.maxY && (s.currentY = s.maxY - 1 + Math.pow(s.currentY - s.maxY + 1, 0.8)), a.prevPositionX || (a.prevPositionX = s.touchesCurrent.x), a.prevPositionY || (a.prevPositionY = s.touchesCurrent.y), a.prevTime || (a.prevTime = Date.now()), a.x = (s.touchesCurrent.x - a.prevPositionX) / (Date.now() - a.prevTime) / 2, a.y = (s.touchesCurrent.y - a.prevPositionY) / (Date.now() - a.prevTime) / 2, Math.abs(s.touchesCurrent.x - a.prevPositionX) < 2 && (a.x = 0), Math.abs(s.touchesCurrent.y - a.prevPositionY) < 2 && (a.y = 0), a.prevPositionX = s.touchesCurrent.x, a.prevPositionY = s.touchesCurrent.y, a.prevTime = Date.now(), i.$imageWrapEl.transform(`translate3d(${s.currentX}px, ${s.currentY}px,0)`); } } }, onTouchEnd() { const e = this.zoom; const t = e.gesture; const i = e.image; const s = e.velocity; if (t.$imageEl && t.$imageEl.length !== 0) { if (!i.isTouched || !i.isMoved) return i.isTouched = !1, void (i.isMoved = !1); i.isTouched = !1, i.isMoved = !1; let a = 300; let r = 300; const n = s.x * a; const o = i.currentX + n; const l = s.y * r; const d = i.currentY + l; s.x !== 0 && (a = Math.abs((o - i.currentX) / s.x)), s.y !== 0 && (r = Math.abs((d - i.currentY) / s.y)); const h = Math.max(a, r); i.currentX = o, i.currentY = d; const p = i.width * e.scale; const c = i.height * e.scale; i.minX = Math.min(t.slideWidth / 2 - p / 2, 0), i.maxX = -i.minX, i.minY = Math.min(t.slideHeight / 2 - c / 2, 0), i.maxY = -i.minY, i.currentX = Math.max(Math.min(i.currentX, i.maxX), i.minX), i.currentY = Math.max(Math.min(i.currentY, i.maxY), i.minY), t.$imageWrapEl.transition(h).transform(`translate3d(${i.currentX}px, ${i.currentY}px,0)`); } }, onTransitionEnd() { const e = this.zoom; const t = e.gesture; t.$slideEl && this.previousIndex !== this.activeIndex && (t.$imageEl && t.$imageEl.transform('translate3d(0,0,0) scale(1)'), t.$imageWrapEl && t.$imageWrapEl.transform('translate3d(0,0,0)'), e.scale = 1, e.currentScale = 1, t.$slideEl = void 0, t.$imageEl = void 0, t.$imageWrapEl = void 0); }, toggle(e) { const t = this.zoom; t.scale && t.scale !== 1 ? t.out() : t.in(e); }, in(e) { let t; let i; let s; let a; let r; let n; let o; let l; let d; let h; let p; let c; let u; let v; let f; let m; const g = this.zoom; const b = this.params.zoom; const w = g.gesture; const y = g.image; (w.$slideEl || (this.params.virtual && this.params.virtual.enabled && this.virtual ? w.$slideEl = this.$wrapperEl.children(`.${this.params.slideActiveClass}`) : w.$slideEl = this.slides.eq(this.activeIndex), w.$imageEl = w.$slideEl.find('img, svg, canvas, picture, .swiper-zoom-target'), w.$imageWrapEl = w.$imageEl.parent(`.${b.containerClass}`)), w.$imageEl && w.$imageEl.length !== 0) && (w.$slideEl.addClass(`${b.zoomedSlideClass}`), void 0 === y.touchesStart.x && e ? (t = e.type === 'touchend' ? e.changedTouches[0].pageX : e.pageX, i = e.type === 'touchend' ? e.changedTouches[0].pageY : e.pageY) : (t = y.touchesStart.x, i = y.touchesStart.y), g.scale = w.$imageWrapEl.attr('data-swiper-zoom') || b.maxRatio, g.currentScale = w.$imageWrapEl.attr('data-swiper-zoom') || b.maxRatio, e ? (f = w.$slideEl[0].offsetWidth, m = w.$slideEl[0].offsetHeight, s = w.$slideEl.offset().left + f / 2 - t, a = w.$slideEl.offset().top + m / 2 - i, o = w.$imageEl[0].offsetWidth, l = w.$imageEl[0].offsetHeight, d = o * g.scale, h = l * g.scale, u = -(p = Math.min(f / 2 - d / 2, 0)), v = -(c = Math.min(m / 2 - h / 2, 0)), (r = s * g.scale) < p && (r = p), r > u && (r = u), (n = a * g.scale) < c && (n = c), n > v && (n = v)) : (r = 0, n = 0), w.$imageWrapEl.transition(300).transform(`translate3d(${r}px, ${n}px,0)`), w.$imageEl.transition(300).transform(`translate3d(0,0,0) scale(${g.scale})`)); }, out() { const e = this.zoom; const t = this.params.zoom; const i = e.gesture; i.$slideEl || (this.params.virtual && this.params.virtual.enabled && this.virtual ? i.$slideEl = this.$wrapperEl.children(`.${this.params.slideActiveClass}`) : i.$slideEl = this.slides.eq(this.activeIndex), i.$imageEl = i.$slideEl.find('img, svg, canvas, picture, .swiper-zoom-target'), i.$imageWrapEl = i.$imageEl.parent(`.${t.containerClass}`)), i.$imageEl && i.$imageEl.length !== 0 && (e.scale = 1, e.currentScale = 1, i.$imageWrapEl.transition(300).transform('translate3d(0,0,0)'), i.$imageEl.transition(300).transform('translate3d(0,0,0) scale(1)'), i.$slideEl.removeClass(`${t.zoomedSlideClass}`), i.$slideEl = void 0); }, enable() { const e = this.zoom; if (!e.enabled) { e.enabled = !0; const t = !(this.touchEvents.start !== 'touchstart' || !o.passiveListener || !this.params.passiveListeners) && { passive: !0, capture: !1 }; const i = !o.passiveListener || { passive: !1, capture: !0 }; const s = `.${this.params.slideClass}`; o.gestures ? (this.$wrapperEl.on('gesturestart', s, e.onGestureStart, t), this.$wrapperEl.on('gesturechange', s, e.onGestureChange, t), this.$wrapperEl.on('gestureend', s, e.onGestureEnd, t)) : this.touchEvents.start === 'touchstart' && (this.$wrapperEl.on(this.touchEvents.start, s, e.onGestureStart, t), this.$wrapperEl.on(this.touchEvents.move, s, e.onGestureChange, i), this.$wrapperEl.on(this.touchEvents.end, s, e.onGestureEnd, t), this.touchEvents.cancel && this.$wrapperEl.on(this.touchEvents.cancel, s, e.onGestureEnd, t)), this.$wrapperEl.on(this.touchEvents.move, `.${this.params.zoom.containerClass}`, e.onTouchMove, i); } }, disable() { const e = this.zoom; if (e.enabled) { this.zoom.enabled = !1; const t = !(this.touchEvents.start !== 'touchstart' || !o.passiveListener || !this.params.passiveListeners) && { passive: !0, capture: !1 }; const i = !o.passiveListener || { passive: !1, capture: !0 }; const s = `.${this.params.slideClass}`; o.gestures ? (this.$wrapperEl.off('gesturestart', s, e.onGestureStart, t), this.$wrapperEl.off('gesturechange', s, e.onGestureChange, t), this.$wrapperEl.off('gestureend', s, e.onGestureEnd, t)) : this.touchEvents.start === 'touchstart' && (this.$wrapperEl.off(this.touchEvents.start, s, e.onGestureStart, t), this.$wrapperEl.off(this.touchEvents.move, s, e.onGestureChange, i), this.$wrapperEl.off(this.touchEvents.end, s, e.onGestureEnd, t), this.touchEvents.cancel && this.$wrapperEl.off(this.touchEvents.cancel, s, e.onGestureEnd, t)), this.$wrapperEl.off(this.touchEvents.move, `.${this.params.zoom.containerClass}`, e.onTouchMove, i); } },
  }; const le = { loadInSlide(e, t) { void 0 === t && (t = !0); const i = this; const a = i.params.lazy; if (void 0 !== e && i.slides.length !== 0) { const r = i.virtual && i.params.virtual.enabled ? i.$wrapperEl.children(`.${i.params.slideClass}[data-swiper-slide-index="${e}"]`) : i.slides.eq(e); let n = r.find(`.${a.elementClass}:not(.${a.loadedClass}):not(.${a.loadingClass})`); !r.hasClass(a.elementClass) || r.hasClass(a.loadedClass) || r.hasClass(a.loadingClass) || (n = n.add(r[0])), n.length !== 0 && n.each(((e, n) => { const o = s(n); o.addClass(a.loadingClass); const l = o.attr('data-background'); const d = o.attr('data-src'); const h = o.attr('data-srcset'); const p = o.attr('data-sizes'); i.loadImage(o[0], d || l, h, p, !1, (() => { if (i != null && i && (!i || i.params) && !i.destroyed) { if (l ? (o.css('background-image', `url("${l}")`), o.removeAttr('data-background')) : (h && (o.attr('srcset', h), o.removeAttr('data-srcset')), p && (o.attr('sizes', p), o.removeAttr('data-sizes')), d && (o.attr('src', d), o.removeAttr('data-src'))), o.addClass(a.loadedClass).removeClass(a.loadingClass), r.find(`.${a.preloaderClass}`).remove(), i.params.loop && t) { const e = r.attr('data-swiper-slide-index'); if (r.hasClass(i.params.slideDuplicateClass)) { const s = i.$wrapperEl.children(`[data-swiper-slide-index="${e}"]:not(.${i.params.slideDuplicateClass})`); i.lazy.loadInSlide(s.index(), !1); } else { const n = i.$wrapperEl.children(`.${i.params.slideDuplicateClass}[data-swiper-slide-index="${e}"]`); i.lazy.loadInSlide(n.index(), !1); } }i.emit('lazyImageReady', r[0], o[0]), i.params.autoHeight && i.updateAutoHeight(); } })), i.emit('lazyImageLoad', r[0], o[0]); })); } }, load() { const e = this; const t = e.$wrapperEl; const i = e.params; const a = e.slides; const r = e.activeIndex; const n = e.virtual && i.virtual.enabled; const o = i.lazy; let l = i.slidesPerView; function d(e) { if (n) { if (t.children(`.${i.slideClass}[data-swiper-slide-index="${e}"]`).length) return !0; } else if (a[e]) return !0; return !1; } function h(e) { return n ? s(e).attr('data-swiper-slide-index') : s(e).index(); } if (l === 'auto' && (l = 0), e.lazy.initialImageLoaded || (e.lazy.initialImageLoaded = !0), e.params.watchSlidesVisibility)t.children(`.${i.slideVisibleClass}`).each(((t, i) => { const a = n ? s(i).attr('data-swiper-slide-index') : s(i).index(); e.lazy.loadInSlide(a); })); else if (l > 1) for (let p = r; p < r + l; p += 1)d(p) && e.lazy.loadInSlide(p); else e.lazy.loadInSlide(r); if (o.loadPrevNext) if (l > 1 || o.loadPrevNextAmount && o.loadPrevNextAmount > 1) { for (var c = o.loadPrevNextAmount, u = l, v = Math.min(r + u + Math.max(c, u), a.length), f = Math.max(r - Math.max(u, c), 0), m = r + l; m < v; m += 1)d(m) && e.lazy.loadInSlide(m); for (let g = f; g < r; g += 1)d(g) && e.lazy.loadInSlide(g); } else { const b = t.children(`.${i.slideNextClass}`); b.length > 0 && e.lazy.loadInSlide(h(b)); const w = t.children(`.${i.slidePrevClass}`); w.length > 0 && e.lazy.loadInSlide(h(w)); } } }; var de = {
    LinearSpline(e, t) { let i; let s; let a; let r; let n; const o = function (e, t) { for (s = -1, i = e.length; i - s > 1;)e[a = i + s >> 1] <= t ? s = a : i = a; return i; }; return this.x = e, this.y = t, this.lastIndex = e.length - 1, this.interpolate = function (e) { return e ? (n = o(this.x, e), r = n - 1, (e - this.x[r]) * (this.y[n] - this.y[r]) / (this.x[n] - this.x[r]) + this.y[r]) : 0; }, this; }, getInterpolateFunction(e) { this.controller.spline || (this.controller.spline = this.params.loop ? new de.LinearSpline(this.slidesGrid, e.slidesGrid) : new de.LinearSpline(this.snapGrid, e.snapGrid)); }, setTranslate(e, t) { let i; let s; const a = this; const r = a.controller.control; function n(e) { const t = a.rtlTranslate ? -a.translate : a.translate; a.params.controller.by === 'slide' && (a.controller.getInterpolateFunction(e), s = -a.controller.spline.interpolate(-t)), s && a.params.controller.by !== 'container' || (i = (e.maxTranslate() - e.minTranslate()) / (a.maxTranslate() - a.minTranslate()), s = (t - a.minTranslate()) * i + e.minTranslate()), a.params.controller.inverse && (s = e.maxTranslate() - s), e.updateProgress(s), e.setTranslate(s, a), e.updateActiveIndex(), e.updateSlidesClasses(); } if (Array.isArray(r)) for (let o = 0; o < r.length; o += 1)r[o] !== t && r[o] instanceof W && n(r[o]); else r instanceof W && t !== r && n(r); }, setTransition(e, t) { let i; const s = this; const a = s.controller.control; function r(t) { t.setTransition(e, s), e !== 0 && (t.transitionStart(), t.params.autoHeight && n.nextTick((() => { t.updateAutoHeight(); })), t.$wrapperEl.transitionEnd((() => { a && (t.params.loop && s.params.controller.by === 'slide' && t.loopFix(), t.transitionEnd()); }))); } if (Array.isArray(a)) for (i = 0; i < a.length; i += 1)a[i] !== t && a[i] instanceof W && r(a[i]); else a instanceof W && t !== a && r(a); },
  }; const he = {
    makeElFocusable(e) { return e.attr('tabIndex', '0'), e; }, addElRole(e, t) { return e.attr('role', t), e; }, addElLabel(e, t) { return e.attr('aria-label', t), e; }, disableEl(e) { return e.attr('aria-disabled', !0), e; }, enableEl(e) { return e.attr('aria-disabled', !1), e; }, onEnterKey(e) { const t = this.params.a11y; if (e.keyCode === 13) { const i = s(e.target); this.navigation && this.navigation.$nextEl && i.is(this.navigation.$nextEl) && (this.isEnd && !this.params.loop || this.slideNext(), this.isEnd ? this.a11y.notify(t.lastSlideMessage) : this.a11y.notify(t.nextSlideMessage)), this.navigation && this.navigation.$prevEl && i.is(this.navigation.$prevEl) && (this.isBeginning && !this.params.loop || this.slidePrev(), this.isBeginning ? this.a11y.notify(t.firstSlideMessage) : this.a11y.notify(t.prevSlideMessage)), this.pagination && i.is(`.${this.params.pagination.bulletClass}`) && i[0].click(); } }, notify(e) { const t = this.a11y.liveRegion; t.length !== 0 && (t.html(''), t.html(e)); }, updateNavigation() { if (!this.params.loop && this.navigation) { const e = this.navigation; const t = e.$nextEl; const i = e.$prevEl; i && i.length > 0 && (this.isBeginning ? this.a11y.disableEl(i) : this.a11y.enableEl(i)), t && t.length > 0 && (this.isEnd ? this.a11y.disableEl(t) : this.a11y.enableEl(t)); } }, updatePagination() { const e = this; const t = e.params.a11y; e.pagination && e.params.pagination.clickable && e.pagination.bullets && e.pagination.bullets.length && e.pagination.bullets.each(((i, a) => { const r = s(a); e.a11y.makeElFocusable(r), e.a11y.addElRole(r, 'button'), e.a11y.addElLabel(r, t.paginationBulletMessage.replace(/\{\{index\}\}/, r.index() + 1)); })); }, init() { this.$el.append(this.a11y.liveRegion); let e; let t; const i = this.params.a11y; this.navigation && this.navigation.$nextEl && (e = this.navigation.$nextEl), this.navigation && this.navigation.$prevEl && (t = this.navigation.$prevEl), e && (this.a11y.makeElFocusable(e), this.a11y.addElRole(e, 'button'), this.a11y.addElLabel(e, i.nextSlideMessage), e.on('keydown', this.a11y.onEnterKey)), t && (this.a11y.makeElFocusable(t), this.a11y.addElRole(t, 'button'), this.a11y.addElLabel(t, i.prevSlideMessage), t.on('keydown', this.a11y.onEnterKey)), this.pagination && this.params.pagination.clickable && this.pagination.bullets && this.pagination.bullets.length && this.pagination.$el.on('keydown', `.${this.params.pagination.bulletClass}`, this.a11y.onEnterKey); }, destroy() { let e; let t; this.a11y.liveRegion && this.a11y.liveRegion.length > 0 && this.a11y.liveRegion.remove(), this.navigation && this.navigation.$nextEl && (e = this.navigation.$nextEl), this.navigation && this.navigation.$prevEl && (t = this.navigation.$prevEl), e && e.off('keydown', this.a11y.onEnterKey), t && t.off('keydown', this.a11y.onEnterKey), this.pagination && this.params.pagination.clickable && this.pagination.bullets && this.pagination.bullets.length && this.pagination.$el.off('keydown', `.${this.params.pagination.bulletClass}`, this.a11y.onEnterKey); },
  }; var pe = {
    init() { if (this.params.history) { if (!t.history || !t.history.pushState) return this.params.history.enabled = !1, void (this.params.hashNavigation.enabled = !0); const e = this.history; e.initialized = !0, e.paths = pe.getPathValues(), (e.paths.key || e.paths.value) && (e.scrollToSlide(0, e.paths.value, this.params.runCallbacksOnInit), this.params.history.replaceState || t.addEventListener('popstate', this.history.setHistoryPopState)); } },
    destroy() { this.params.history.replaceState || t.removeEventListener('popstate', this.history.setHistoryPopState); },
    setHistoryPopState() { this.history.paths = pe.getPathValues(), this.history.scrollToSlide(this.params.speed, this.history.paths.value, !1); },
    getPathValues() { const e = t.location.pathname.slice(1).split('/').filter(((e) => e !== '')); const i = e.length; return { key: e[i - 2], value: e[i - 1] }; },
    setHistory(e, i) { if (this.history.initialized && this.params.history.enabled) { const s = this.slides.eq(i); let a = pe.slugify(s.attr('data-history')); t.location.pathname.includes(e) || (a = `${e}/${a}`); const r = t.history.state; r && r.value === a || (this.params.history.replaceState ? t.history.replaceState({ value: a }, null, a) : t.history.pushState({ value: a }, null, a)); } },
    slugify(e) {
      return e.toString().replace(/\s+/g, '-').replace(/[^\w-]+/g, '').replace(/--+/g, '-')
        .replace(/^-+/, '')
        .replace(/-+$/, '');
    },
    scrollToSlide(e, t, i) { if (t) for (let s = 0, a = this.slides.length; s < a; s += 1) { const r = this.slides.eq(s); if (pe.slugify(r.attr('data-history')) === t && !r.hasClass(this.params.slideDuplicateClass)) { const n = r.index(); this.slideTo(n, e, i); } } else this.slideTo(0, e, i); },
  }; const ce = {
    onHashCange() { const t = e.location.hash.replace('#', ''); if (t !== this.slides.eq(this.activeIndex).attr('data-hash')) { const i = this.$wrapperEl.children(`.${this.params.slideClass}[data-hash="${t}"]`).index(); if (void 0 === i) return; this.slideTo(i); } }, setHash() { if (this.hashNavigation.initialized && this.params.hashNavigation.enabled) if (this.params.hashNavigation.replaceState && t.history && t.history.replaceState)t.history.replaceState(null, null, `#${this.slides.eq(this.activeIndex).attr('data-hash')}` || ''); else { const i = this.slides.eq(this.activeIndex); const s = i.attr('data-hash') || i.attr('data-history'); e.location.hash = s || ''; } }, init() { if (!(!this.params.hashNavigation.enabled || this.params.history && this.params.history.enabled)) { this.hashNavigation.initialized = !0; const i = e.location.hash.replace('#', ''); if (i) for (let a = 0, r = this.slides.length; a < r; a += 1) { const n = this.slides.eq(a); if ((n.attr('data-hash') || n.attr('data-history')) === i && !n.hasClass(this.params.slideDuplicateClass)) { const o = n.index(); this.slideTo(o, 0, this.params.runCallbacksOnInit, !0); } } this.params.hashNavigation.watchState && s(t).on('hashchange', this.hashNavigation.onHashCange); } }, destroy() { this.params.hashNavigation.watchState && s(t).off('hashchange', this.hashNavigation.onHashCange); },
  }; const ue = {
    run() { const e = this; const t = e.slides.eq(e.activeIndex); let i = e.params.autoplay.delay; t.attr('data-swiper-autoplay') && (i = t.attr('data-swiper-autoplay') || e.params.autoplay.delay), clearTimeout(e.autoplay.timeout), e.autoplay.timeout = n.nextTick((() => { e.params.autoplay.reverseDirection ? e.params.loop ? (e.loopFix(), e.slidePrev(e.params.speed, !0, !0), e.emit('autoplay')) : e.isBeginning ? e.params.autoplay.stopOnLastSlide ? e.autoplay.stop() : (e.slideTo(e.slides.length - 1, e.params.speed, !0, !0), e.emit('autoplay')) : (e.slidePrev(e.params.speed, !0, !0), e.emit('autoplay')) : e.params.loop ? (e.loopFix(), e.slideNext(e.params.speed, !0, !0), e.emit('autoplay')) : e.isEnd ? e.params.autoplay.stopOnLastSlide ? e.autoplay.stop() : (e.slideTo(0, e.params.speed, !0, !0), e.emit('autoplay')) : (e.slideNext(e.params.speed, !0, !0), e.emit('autoplay')), e.params.cssMode && e.autoplay.running && e.autoplay.run(); }), i); }, start() { return void 0 === this.autoplay.timeout && (!this.autoplay.running && (this.autoplay.running = !0, this.emit('autoplayStart'), this.autoplay.run(), !0)); }, stop() { return !!this.autoplay.running && (void 0 !== this.autoplay.timeout && (this.autoplay.timeout && (clearTimeout(this.autoplay.timeout), this.autoplay.timeout = void 0), this.autoplay.running = !1, this.emit('autoplayStop'), !0)); }, pause(e) { this.autoplay.running && (this.autoplay.paused || (this.autoplay.timeout && clearTimeout(this.autoplay.timeout), this.autoplay.paused = !0, e !== 0 && this.params.autoplay.waitForTransition ? (this.$wrapperEl[0].addEventListener('transitionend', this.autoplay.onTransitionEnd), this.$wrapperEl[0].addEventListener('webkitTransitionEnd', this.autoplay.onTransitionEnd)) : (this.autoplay.paused = !1, this.autoplay.run()))); },
  }; const ve = { setTranslate() { for (let e = this.slides, t = 0; t < e.length; t += 1) { const i = this.slides.eq(t); let s = -i[0].swiperSlideOffset; this.params.virtualTranslate || (s -= this.translate); let a = 0; this.isHorizontal() || (a = s, s = 0); const r = this.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(i[0].progress), 0) : 1 + Math.min(Math.max(i[0].progress, -1), 0); i.css({ opacity: r }).transform(`translate3d(${s}px, ${a}px, 0px)`); } }, setTransition(e) { const t = this; const i = t.slides; const s = t.$wrapperEl; if (i.transition(e), t.params.virtualTranslate && e !== 0) { let a = !1; i.transitionEnd((() => { if (!a && t && !t.destroyed) { a = !0, t.animating = !1; for (let e = ['webkitTransitionEnd', 'transitionend'], i = 0; i < e.length; i += 1)s.trigger(e[i]); } })); } } }; const fe = {
    setTranslate() {
      let e; const t = this.$el; const i = this.$wrapperEl; const a = this.slides; const r = this.width; const n = this.height; const o = this.rtlTranslate; const l = this.size; const d = this.params.cubeEffect; const h = this.isHorizontal(); const p = this.virtual && this.params.virtual.enabled; let c = 0; d.shadow && (h ? ((e = i.find('.swiper-cube-shadow')).length === 0 && (e = s('<div class="swiper-cube-shadow"></div>'), i.append(e)), e.css({ height: `${r}px` })) : (e = t.find('.swiper-cube-shadow')).length === 0 && (e = s('<div class="swiper-cube-shadow"></div>'), t.append(e))); for (let u = 0; u < a.length; u += 1) { const v = a.eq(u); let f = u; p && (f = parseInt(v.attr('data-swiper-slide-index'), 10)); let m = 90 * f; let g = Math.floor(m / 360); o && (m = -m, g = Math.floor(-m / 360)); const b = Math.max(Math.min(v[0].progress, 1), -1); let w = 0; let y = 0; let x = 0; f % 4 == 0 ? (w = 4 * -g * l, x = 0) : (f - 1) % 4 == 0 ? (w = 0, x = 4 * -g * l) : (f - 2) % 4 == 0 ? (w = l + 4 * g * l, x = l) : (f - 3) % 4 == 0 && (w = -l, x = 3 * l + 4 * l * g), o && (w = -w), h || (y = w, w = 0); const T = `rotateX(${h ? 0 : -m}deg) rotateY(${h ? m : 0}deg) translate3d(${w}px, ${y}px, ${x}px)`; if (b <= 1 && b > -1 && (c = 90 * f + 90 * b, o && (c = 90 * -f - 90 * b)), v.transform(T), d.slideShadows) { let E = h ? v.find('.swiper-slide-shadow-left') : v.find('.swiper-slide-shadow-top'); let S = h ? v.find('.swiper-slide-shadow-right') : v.find('.swiper-slide-shadow-bottom'); E.length === 0 && (E = s(`<div class="swiper-slide-shadow-${h ? 'left' : 'top'}"></div>`), v.append(E)), S.length === 0 && (S = s(`<div class="swiper-slide-shadow-${h ? 'right' : 'bottom'}"></div>`), v.append(S)), E.length && (E[0].style.opacity = Math.max(-b, 0)), S.length && (S[0].style.opacity = Math.max(b, 0)); } } if (i.css({
        '-webkit-transform-origin': `50% 50% -${l / 2}px`, '-moz-transform-origin': `50% 50% -${l / 2}px`, '-ms-transform-origin': `50% 50% -${l / 2}px`, 'transform-origin': `50% 50% -${l / 2}px`,
      }), d.shadow) if (h)e.transform(`translate3d(0px, ${r / 2 + d.shadowOffset}px, ${-r / 2}px) rotateX(90deg) rotateZ(0deg) scale(${d.shadowScale})`); else { const C = Math.abs(c) - 90 * Math.floor(Math.abs(c) / 90); const M = 1.5 - (Math.sin(2 * C * Math.PI / 360) / 2 + Math.cos(2 * C * Math.PI / 360) / 2); const P = d.shadowScale; const z = d.shadowScale / M; const k = d.shadowOffset; e.transform(`scale3d(${P}, 1, ${z}) translate3d(0px, ${n / 2 + k}px, ${-n / 2 / z}px) rotateX(-90deg)`); } const $ = j.isSafari || j.isUiWebView ? -l / 2 : 0; i.transform(`translate3d(0px,0,${$}px) rotateX(${this.isHorizontal() ? 0 : c}deg) rotateY(${this.isHorizontal() ? -c : 0}deg)`);
    },
    setTransition(e) { const t = this.$el; this.slides.transition(e).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(e), this.params.cubeEffect.shadow && !this.isHorizontal() && t.find('.swiper-cube-shadow').transition(e); },
  }; const me = { setTranslate() { for (let e = this.slides, t = this.rtlTranslate, i = 0; i < e.length; i += 1) { const a = e.eq(i); let r = a[0].progress; this.params.flipEffect.limitRotation && (r = Math.max(Math.min(a[0].progress, 1), -1)); let n = -180 * r; let o = 0; let l = -a[0].swiperSlideOffset; let d = 0; if (this.isHorizontal() ? t && (n = -n) : (d = l, l = 0, o = -n, n = 0), a[0].style.zIndex = -Math.abs(Math.round(r)) + e.length, this.params.flipEffect.slideShadows) { let h = this.isHorizontal() ? a.find('.swiper-slide-shadow-left') : a.find('.swiper-slide-shadow-top'); let p = this.isHorizontal() ? a.find('.swiper-slide-shadow-right') : a.find('.swiper-slide-shadow-bottom'); h.length === 0 && (h = s(`<div class="swiper-slide-shadow-${this.isHorizontal() ? 'left' : 'top'}"></div>`), a.append(h)), p.length === 0 && (p = s(`<div class="swiper-slide-shadow-${this.isHorizontal() ? 'right' : 'bottom'}"></div>`), a.append(p)), h.length && (h[0].style.opacity = Math.max(-r, 0)), p.length && (p[0].style.opacity = Math.max(r, 0)); }a.transform(`translate3d(${l}px, ${d}px, 0px) rotateX(${o}deg) rotateY(${n}deg)`); } }, setTransition(e) { const t = this; const i = t.slides; const s = t.activeIndex; const a = t.$wrapperEl; if (i.transition(e).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(e), t.params.virtualTranslate && e !== 0) { let r = !1; i.eq(s).transitionEnd((() => { if (!r && t && !t.destroyed) { r = !0, t.animating = !1; for (let e = ['webkitTransitionEnd', 'transitionend'], i = 0; i < e.length; i += 1)a.trigger(e[i]); } })); } } }; const ge = { setTranslate() { for (var e = this.width, t = this.height, i = this.slides, a = this.$wrapperEl, r = this.slidesSizesGrid, n = this.params.coverflowEffect, l = this.isHorizontal(), d = this.translate, h = l ? e / 2 - d : t / 2 - d, p = l ? n.rotate : -n.rotate, c = n.depth, u = 0, v = i.length; u < v; u += 1) { const f = i.eq(u); const m = r[u]; const g = (h - f[0].swiperSlideOffset - m / 2) / m * n.modifier; let b = l ? p * g : 0; let w = l ? 0 : p * g; let y = -c * Math.abs(g); let x = n.stretch; typeof x === 'string' && x.indexOf('%') !== -1 && (x = parseFloat(n.stretch) / 100 * m); let T = l ? 0 : x * g; let E = l ? x * g : 0; Math.abs(E) < 0.001 && (E = 0), Math.abs(T) < 0.001 && (T = 0), Math.abs(y) < 0.001 && (y = 0), Math.abs(b) < 0.001 && (b = 0), Math.abs(w) < 0.001 && (w = 0); const S = `translate3d(${E}px,${T}px,${y}px)  rotateX(${w}deg) rotateY(${b}deg)`; if (f.transform(S), f[0].style.zIndex = 1 - Math.abs(Math.round(g)), n.slideShadows) { let C = l ? f.find('.swiper-slide-shadow-left') : f.find('.swiper-slide-shadow-top'); let M = l ? f.find('.swiper-slide-shadow-right') : f.find('.swiper-slide-shadow-bottom'); C.length === 0 && (C = s(`<div class="swiper-slide-shadow-${l ? 'left' : 'top'}"></div>`), f.append(C)), M.length === 0 && (M = s(`<div class="swiper-slide-shadow-${l ? 'right' : 'bottom'}"></div>`), f.append(M)), C.length && (C[0].style.opacity = g > 0 ? g : 0), M.length && (M[0].style.opacity = -g > 0 ? -g : 0); } }(o.pointerEvents || o.prefixedPointerEvents) && (a[0].style.perspectiveOrigin = `${h}px 50%`); }, setTransition(e) { this.slides.transition(e).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(e); } }; const be = { init() { const e = this.params.thumbs; const t = this.constructor; e.swiper instanceof t ? (this.thumbs.swiper = e.swiper, n.extend(this.thumbs.swiper.originalParams, { watchSlidesProgress: !0, slideToClickedSlide: !1 }), n.extend(this.thumbs.swiper.params, { watchSlidesProgress: !0, slideToClickedSlide: !1 })) : n.isObject(e.swiper) && (this.thumbs.swiper = new t(n.extend({}, e.swiper, { watchSlidesVisibility: !0, watchSlidesProgress: !0, slideToClickedSlide: !1 })), this.thumbs.swiperCreated = !0), this.thumbs.swiper.$el.addClass(this.params.thumbs.thumbsContainerClass), this.thumbs.swiper.on('tap', this.thumbs.onThumbClick); }, onThumbClick() { const e = this.thumbs.swiper; if (e) { const t = e.clickedIndex; const i = e.clickedSlide; if (!(i && s(i).hasClass(this.params.thumbs.slideThumbActiveClass) || t == null)) { let a; if (a = e.params.loop ? parseInt(s(e.clickedSlide).attr('data-swiper-slide-index'), 10) : t, this.params.loop) { let r = this.activeIndex; this.slides.eq(r).hasClass(this.params.slideDuplicateClass) && (this.loopFix(), this._clientLeft = this.$wrapperEl[0].clientLeft, r = this.activeIndex); const n = this.slides.eq(r).prevAll(`[data-swiper-slide-index="${a}"]`).eq(0).index(); const o = this.slides.eq(r).nextAll(`[data-swiper-slide-index="${a}"]`).eq(0).index(); a = void 0 === n ? o : void 0 === o ? n : o - r < r - n ? o : n; } this.slideTo(a); } } }, update(e) { const t = this.thumbs.swiper; if (t) { const i = t.params.slidesPerView === 'auto' ? t.slidesPerViewDynamic() : t.params.slidesPerView; const s = this.params.thumbs.autoScrollOffset; const a = s && !t.params.loop; if (this.realIndex !== t.realIndex || a) { let r; let n; let o = t.activeIndex; if (t.params.loop) { t.slides.eq(o).hasClass(t.params.slideDuplicateClass) && (t.loopFix(), t._clientLeft = t.$wrapperEl[0].clientLeft, o = t.activeIndex); const l = t.slides.eq(o).prevAll(`[data-swiper-slide-index="${this.realIndex}"]`).eq(0).index(); const d = t.slides.eq(o).nextAll(`[data-swiper-slide-index="${this.realIndex}"]`).eq(0).index(); r = void 0 === l ? d : void 0 === d ? l : d - o == o - l ? o : d - o < o - l ? d : l, n = this.activeIndex > this.previousIndex ? 'next' : 'prev'; } else n = (r = this.realIndex) > this.previousIndex ? 'next' : 'prev'; a && (r += n === 'next' ? s : -1 * s), t.visibleSlidesIndexes && t.visibleSlidesIndexes.indexOf(r) < 0 && (t.params.centeredSlides ? r = r > o ? r - Math.floor(i / 2) + 1 : r + Math.floor(i / 2) - 1 : r > o && (r = r - i + 1), t.slideTo(r, e ? 0 : void 0)); } let h = 1; const p = this.params.thumbs.slideThumbActiveClass; if (this.params.slidesPerView > 1 && !this.params.centeredSlides && (h = this.params.slidesPerView), this.params.thumbs.multipleActiveThumbs || (h = 1), h = Math.floor(h), t.slides.removeClass(p), t.params.loop || t.params.virtual && t.params.virtual.enabled) for (let c = 0; c < h; c += 1)t.$wrapperEl.children(`[data-swiper-slide-index="${this.realIndex + c}"]`).addClass(p); else for (let u = 0; u < h; u += 1)t.slides.eq(this.realIndex + u).addClass(p); } } }; const we = [R, q, K, U, Z, J, te, {
    name: 'mousewheel',
    params: {
      mousewheel: {
        enabled: !1, releaseOnEdges: !1, invert: !1, forceToAxis: !1, sensitivity: 1, eventsTarged: 'container',
      },
    },
    create() {
      n.extend(this, {
        mousewheel: {
          enabled: !1, enable: ie.enable.bind(this), disable: ie.disable.bind(this), handle: ie.handle.bind(this), handleMouseEnter: ie.handleMouseEnter.bind(this), handleMouseLeave: ie.handleMouseLeave.bind(this), animateSlider: ie.animateSlider.bind(this), releaseScroll: ie.releaseScroll.bind(this), lastScrollTime: n.now(), lastEventBeforeSnap: void 0, recentWheelEvents: [],
        },
      });
    },
    on: { init() { !this.params.mousewheel.enabled && this.params.cssMode && this.mousewheel.disable(), this.params.mousewheel.enabled && this.mousewheel.enable(); }, destroy() { this.params.cssMode && this.mousewheel.enable(), this.mousewheel.enabled && this.mousewheel.disable(); } },
  }, {
    name: 'navigation',
    params: {
      navigation: {
        nextEl: null, prevEl: null, hideOnClick: !1, disabledClass: 'swiper-button-disabled', hiddenClass: 'swiper-button-hidden', lockClass: 'swiper-button-lock',
      },
    },
    create() {
      n.extend(this, {
        navigation: {
          init: se.init.bind(this), update: se.update.bind(this), destroy: se.destroy.bind(this), onNextClick: se.onNextClick.bind(this), onPrevClick: se.onPrevClick.bind(this),
        },
      });
    },
    on: {
      init() { this.navigation.init(), this.navigation.update(); }, toEdge() { this.navigation.update(); }, fromEdge() { this.navigation.update(); }, destroy() { this.navigation.destroy(); }, click(e) { let t; const i = this.navigation; const a = i.$nextEl; const r = i.$prevEl; !this.params.navigation.hideOnClick || s(e.target).is(r) || s(e.target).is(a) || (a ? t = a.hasClass(this.params.navigation.hiddenClass) : r && (t = r.hasClass(this.params.navigation.hiddenClass)), !0 === t ? this.emit('navigationShow', this) : this.emit('navigationHide', this), a && a.toggleClass(this.params.navigation.hiddenClass), r && r.toggleClass(this.params.navigation.hiddenClass)); },
    },
  }, {
    name: 'pagination',
    params: {
      pagination: {
        el: null, bulletElement: 'span', clickable: !1, hideOnClick: !1, renderBullet: null, renderProgressbar: null, renderFraction: null, renderCustom: null, progressbarOpposite: !1, type: 'bullets', dynamicBullets: !1, dynamicMainBullets: 1, formatFractionCurrent(e) { return e; }, formatFractionTotal(e) { return e; }, bulletClass: 'swiper-pagination-bullet', bulletActiveClass: 'swiper-pagination-bullet-active', modifierClass: 'swiper-pagination-', currentClass: 'swiper-pagination-current', totalClass: 'swiper-pagination-total', hiddenClass: 'swiper-pagination-hidden', progressbarFillClass: 'swiper-pagination-progressbar-fill', progressbarOppositeClass: 'swiper-pagination-progressbar-opposite', clickableClass: 'swiper-pagination-clickable', lockClass: 'swiper-pagination-lock',
      },
    },
    create() {
      n.extend(this, {
        pagination: {
          init: ae.init.bind(this), render: ae.render.bind(this), update: ae.update.bind(this), destroy: ae.destroy.bind(this), dynamicBulletIndex: 0,
        },
      });
    },
    on: {
      init() { this.pagination.init(), this.pagination.render(), this.pagination.update(); }, activeIndexChange() { (this.params.loop || void 0 === this.snapIndex) && this.pagination.update(); }, snapIndexChange() { this.params.loop || this.pagination.update(); }, slidesLengthChange() { this.params.loop && (this.pagination.render(), this.pagination.update()); }, snapGridLengthChange() { this.params.loop || (this.pagination.render(), this.pagination.update()); }, destroy() { this.pagination.destroy(); }, click(e) { this.params.pagination.el && this.params.pagination.hideOnClick && this.pagination.$el.length > 0 && !s(e.target).hasClass(this.params.pagination.bulletClass) && (!0 === this.pagination.$el.hasClass(this.params.pagination.hiddenClass) ? this.emit('paginationShow', this) : this.emit('paginationHide', this), this.pagination.$el.toggleClass(this.params.pagination.hiddenClass)); },
    },
  }, {
    name: 'scrollbar',
    params: {
      scrollbar: {
        el: null, dragSize: 'auto', hide: !1, draggable: !1, snapOnRelease: !0, lockClass: 'swiper-scrollbar-lock', dragClass: 'swiper-scrollbar-drag',
      },
    },
    create() {
      n.extend(this, {
        scrollbar: {
          init: re.init.bind(this), destroy: re.destroy.bind(this), updateSize: re.updateSize.bind(this), setTranslate: re.setTranslate.bind(this), setTransition: re.setTransition.bind(this), enableDraggable: re.enableDraggable.bind(this), disableDraggable: re.disableDraggable.bind(this), setDragPosition: re.setDragPosition.bind(this), getPointerPosition: re.getPointerPosition.bind(this), onDragStart: re.onDragStart.bind(this), onDragMove: re.onDragMove.bind(this), onDragEnd: re.onDragEnd.bind(this), isTouched: !1, timeout: null, dragTimeout: null,
        },
      });
    },
    on: {
      init() { this.scrollbar.init(), this.scrollbar.updateSize(), this.scrollbar.setTranslate(); }, update() { this.scrollbar.updateSize(); }, resize() { this.scrollbar.updateSize(); }, observerUpdate() { this.scrollbar.updateSize(); }, setTranslate() { this.scrollbar.setTranslate(); }, setTransition(e) { this.scrollbar.setTransition(e); }, destroy() { this.scrollbar.destroy(); },
    },
  }, {
    name: 'parallax',
    params: { parallax: { enabled: !1 } },
    create() { n.extend(this, { parallax: { setTransform: ne.setTransform.bind(this), setTranslate: ne.setTranslate.bind(this), setTransition: ne.setTransition.bind(this) } }); },
    on: {
      beforeInit() { this.params.parallax.enabled && (this.params.watchSlidesProgress = !0, this.originalParams.watchSlidesProgress = !0); }, init() { this.params.parallax.enabled && this.parallax.setTranslate(); }, setTranslate() { this.params.parallax.enabled && this.parallax.setTranslate(); }, setTransition(e) { this.params.parallax.enabled && this.parallax.setTransition(e); },
    },
  }, {
    name: 'zoom',
    params: {
      zoom: {
        enabled: !1, maxRatio: 3, minRatio: 1, toggle: !0, containerClass: 'swiper-zoom-container', zoomedSlideClass: 'swiper-slide-zoomed',
      },
    },
    create() {
      const e = this; const t = {
        enabled: !1,
        scale: 1,
        currentScale: 1,
        isScaling: !1,
        gesture: {
          $slideEl: void 0, slideWidth: void 0, slideHeight: void 0, $imageEl: void 0, $imageWrapEl: void 0, maxRatio: 3,
        },
        image: {
          isTouched: void 0, isMoved: void 0, currentX: void 0, currentY: void 0, minX: void 0, minY: void 0, maxX: void 0, maxY: void 0, width: void 0, height: void 0, startX: void 0, startY: void 0, touchesStart: {}, touchesCurrent: {},
        },
        velocity: {
          x: void 0, y: void 0, prevPositionX: void 0, prevPositionY: void 0, prevTime: void 0,
        },
      }; 'onGestureStart onGestureChange onGestureEnd onTouchStart onTouchMove onTouchEnd onTransitionEnd toggle enable disable in out'.split(' ').forEach(((i) => { t[i] = oe[i].bind(e); })), n.extend(e, { zoom: t }); let i = 1; Object.defineProperty(e.zoom, 'scale', { get() { return i; }, set(t) { if (i !== t) { const s = e.zoom.gesture.$imageEl ? e.zoom.gesture.$imageEl[0] : void 0; const a = e.zoom.gesture.$slideEl ? e.zoom.gesture.$slideEl[0] : void 0; e.emit('zoomChange', t, s, a); }i = t; } });
    },
    on: {
      init() { this.params.zoom.enabled && this.zoom.enable(); }, destroy() { this.zoom.disable(); }, touchStart(e) { this.zoom.enabled && this.zoom.onTouchStart(e); }, touchEnd(e) { this.zoom.enabled && this.zoom.onTouchEnd(e); }, doubleTap(e) { this.params.zoom.enabled && this.zoom.enabled && this.params.zoom.toggle && this.zoom.toggle(e); }, transitionEnd() { this.zoom.enabled && this.params.zoom.enabled && this.zoom.onTransitionEnd(); }, slideChange() { this.zoom.enabled && this.params.zoom.enabled && this.params.cssMode && this.zoom.onTransitionEnd(); },
    },
  }, {
    name: 'lazy',
    params: {
      lazy: {
        enabled: !1, loadPrevNext: !1, loadPrevNextAmount: 1, loadOnTransitionStart: !1, elementClass: 'swiper-lazy', loadingClass: 'swiper-lazy-loading', loadedClass: 'swiper-lazy-loaded', preloaderClass: 'swiper-lazy-preloader',
      },
    },
    create() { n.extend(this, { lazy: { initialImageLoaded: !1, load: le.load.bind(this), loadInSlide: le.loadInSlide.bind(this) } }); },
    on: {
      beforeInit() { this.params.lazy.enabled && this.params.preloadImages && (this.params.preloadImages = !1); }, init() { this.params.lazy.enabled && !this.params.loop && this.params.initialSlide === 0 && this.lazy.load(); }, scroll() { this.params.freeMode && !this.params.freeModeSticky && this.lazy.load(); }, resize() { this.params.lazy.enabled && this.lazy.load(); }, scrollbarDragMove() { this.params.lazy.enabled && this.lazy.load(); }, transitionStart() { this.params.lazy.enabled && (this.params.lazy.loadOnTransitionStart || !this.params.lazy.loadOnTransitionStart && !this.lazy.initialImageLoaded) && this.lazy.load(); }, transitionEnd() { this.params.lazy.enabled && !this.params.lazy.loadOnTransitionStart && this.lazy.load(); }, slideChange() { this.params.lazy.enabled && this.params.cssMode && this.lazy.load(); },
    },
  }, {
    name: 'controller',
    params: { controller: { control: void 0, inverse: !1, by: 'slide' } },
    create() {
      n.extend(this, {
        controller: {
          control: this.params.controller.control, getInterpolateFunction: de.getInterpolateFunction.bind(this), setTranslate: de.setTranslate.bind(this), setTransition: de.setTransition.bind(this),
        },
      });
    },
    on: {
      update() { this.controller.control && this.controller.spline && (this.controller.spline = void 0, delete this.controller.spline); }, resize() { this.controller.control && this.controller.spline && (this.controller.spline = void 0, delete this.controller.spline); }, observerUpdate() { this.controller.control && this.controller.spline && (this.controller.spline = void 0, delete this.controller.spline); }, setTranslate(e, t) { this.controller.control && this.controller.setTranslate(e, t); }, setTransition(e, t) { this.controller.control && this.controller.setTransition(e, t); },
    },
  }, {
    name: 'a11y',
    params: {
      a11y: {
        enabled: !0, notificationClass: 'swiper-notification', prevSlideMessage: 'Previous slide', nextSlideMessage: 'Next slide', firstSlideMessage: 'This is the first slide', lastSlideMessage: 'This is the last slide', paginationBulletMessage: 'Go to slide {{index}}',
      },
    },
    create() { const e = this; n.extend(e, { a11y: { liveRegion: s(`<span class="${e.params.a11y.notificationClass}" aria-live="assertive" aria-atomic="true"></span>`) } }), Object.keys(he).forEach(((t) => { e.a11y[t] = he[t].bind(e); })); },
    on: {
      init() { this.params.a11y.enabled && (this.a11y.init(), this.a11y.updateNavigation()); }, toEdge() { this.params.a11y.enabled && this.a11y.updateNavigation(); }, fromEdge() { this.params.a11y.enabled && this.a11y.updateNavigation(); }, paginationUpdate() { this.params.a11y.enabled && this.a11y.updatePagination(); }, destroy() { this.params.a11y.enabled && this.a11y.destroy(); },
    },
  }, {
    name: 'history',
    params: { history: { enabled: !1, replaceState: !1, key: 'slides' } },
    create() {
      n.extend(this, {
        history: {
          init: pe.init.bind(this), setHistory: pe.setHistory.bind(this), setHistoryPopState: pe.setHistoryPopState.bind(this), scrollToSlide: pe.scrollToSlide.bind(this), destroy: pe.destroy.bind(this),
        },
      });
    },
    on: {
      init() { this.params.history.enabled && this.history.init(); }, destroy() { this.params.history.enabled && this.history.destroy(); }, transitionEnd() { this.history.initialized && this.history.setHistory(this.params.history.key, this.activeIndex); }, slideChange() { this.history.initialized && this.params.cssMode && this.history.setHistory(this.params.history.key, this.activeIndex); },
    },
  }, {
    name: 'hash-navigation',
    params: { hashNavigation: { enabled: !1, replaceState: !1, watchState: !1 } },
    create() {
      n.extend(this, {
        hashNavigation: {
          initialized: !1, init: ce.init.bind(this), destroy: ce.destroy.bind(this), setHash: ce.setHash.bind(this), onHashCange: ce.onHashCange.bind(this),
        },
      });
    },
    on: {
      init() { this.params.hashNavigation.enabled && this.hashNavigation.init(); }, destroy() { this.params.hashNavigation.enabled && this.hashNavigation.destroy(); }, transitionEnd() { this.hashNavigation.initialized && this.hashNavigation.setHash(); }, slideChange() { this.hashNavigation.initialized && this.params.cssMode && this.hashNavigation.setHash(); },
    },
  }, {
    name: 'autoplay',
    params: {
      autoplay: {
        enabled: !1, delay: 3e3, waitForTransition: !0, disableOnInteraction: !0, stopOnLastSlide: !1, reverseDirection: !1,
      },
    },
    create() {
      const e = this; n.extend(e, {
        autoplay: {
          running: !1, paused: !1, run: ue.run.bind(e), start: ue.start.bind(e), stop: ue.stop.bind(e), pause: ue.pause.bind(e), onVisibilityChange() { document.visibilityState === 'hidden' && e.autoplay.running && e.autoplay.pause(), document.visibilityState === 'visible' && e.autoplay.paused && (e.autoplay.run(), e.autoplay.paused = !1); }, onTransitionEnd(t) { e && !e.destroyed && e.$wrapperEl && t.target === this && (e.$wrapperEl[0].removeEventListener('transitionend', e.autoplay.onTransitionEnd), e.$wrapperEl[0].removeEventListener('webkitTransitionEnd', e.autoplay.onTransitionEnd), e.autoplay.paused = !1, e.autoplay.running ? e.autoplay.run() : e.autoplay.stop()); },
        },
      });
    },
    on: {
      init() { this.params.autoplay.enabled && (this.autoplay.start(), document.addEventListener('visibilitychange', this.autoplay.onVisibilityChange)); }, beforeTransitionStart(e, t) { this.autoplay.running && (t || !this.params.autoplay.disableOnInteraction ? this.autoplay.pause(e) : this.autoplay.stop()); }, sliderFirstMove() { this.autoplay.running && (this.params.autoplay.disableOnInteraction ? this.autoplay.stop() : this.autoplay.pause()); }, touchEnd() { this.params.cssMode && this.autoplay.paused && !this.params.autoplay.disableOnInteraction && this.autoplay.run(); }, destroy() { this.autoplay.running && this.autoplay.stop(), document.removeEventListener('visibilitychange', this.autoplay.onVisibilityChange); },
    },
  }, {
    name: 'effect-fade',
    params: { fadeEffect: { crossFade: !1 } },
    create() { n.extend(this, { fadeEffect: { setTranslate: ve.setTranslate.bind(this), setTransition: ve.setTransition.bind(this) } }); },
    on: {
      beforeInit() {
        if (this.params.effect === 'fade') {
          this.classNames.push(`${this.params.containerModifierClass}fade`); const e = {
            slidesPerView: 1, slidesPerColumn: 1, slidesPerGroup: 1, watchSlidesProgress: !0, spaceBetween: 0, virtualTranslate: !0,
          }; n.extend(this.params, e), n.extend(this.originalParams, e);
        }
      },
      setTranslate() { this.params.effect === 'fade' && this.fadeEffect.setTranslate(); },
      setTransition(e) { this.params.effect === 'fade' && this.fadeEffect.setTransition(e); },
    },
  }, {
    name: 'effect-cube',
    params: {
      cubeEffect: {
        slideShadows: !0, shadow: !0, shadowOffset: 20, shadowScale: 0.94,
      },
    },
    create() { n.extend(this, { cubeEffect: { setTranslate: fe.setTranslate.bind(this), setTransition: fe.setTransition.bind(this) } }); },
    on: {
      beforeInit() {
        if (this.params.effect === 'cube') {
          this.classNames.push(`${this.params.containerModifierClass}cube`), this.classNames.push(`${this.params.containerModifierClass}3d`); const e = {
            slidesPerView: 1, slidesPerColumn: 1, slidesPerGroup: 1, watchSlidesProgress: !0, resistanceRatio: 0, spaceBetween: 0, centeredSlides: !1, virtualTranslate: !0,
          }; n.extend(this.params, e), n.extend(this.originalParams, e);
        }
      },
      setTranslate() { this.params.effect === 'cube' && this.cubeEffect.setTranslate(); },
      setTransition(e) { this.params.effect === 'cube' && this.cubeEffect.setTransition(e); },
    },
  }, {
    name: 'effect-flip',
    params: { flipEffect: { slideShadows: !0, limitRotation: !0 } },
    create() { n.extend(this, { flipEffect: { setTranslate: me.setTranslate.bind(this), setTransition: me.setTransition.bind(this) } }); },
    on: {
      beforeInit() {
        if (this.params.effect === 'flip') {
          this.classNames.push(`${this.params.containerModifierClass}flip`), this.classNames.push(`${this.params.containerModifierClass}3d`); const e = {
            slidesPerView: 1, slidesPerColumn: 1, slidesPerGroup: 1, watchSlidesProgress: !0, spaceBetween: 0, virtualTranslate: !0,
          }; n.extend(this.params, e), n.extend(this.originalParams, e);
        }
      },
      setTranslate() { this.params.effect === 'flip' && this.flipEffect.setTranslate(); },
      setTransition(e) { this.params.effect === 'flip' && this.flipEffect.setTransition(e); },
    },
  }, {
    name: 'effect-coverflow',
    params: {
      coverflowEffect: {
        rotate: 50, stretch: 0, depth: 100, modifier: 1, slideShadows: !0,
      },
    },
    create() { n.extend(this, { coverflowEffect: { setTranslate: ge.setTranslate.bind(this), setTransition: ge.setTransition.bind(this) } }); },
    on: { beforeInit() { this.params.effect === 'coverflow' && (this.classNames.push(`${this.params.containerModifierClass}coverflow`), this.classNames.push(`${this.params.containerModifierClass}3d`), this.params.watchSlidesProgress = !0, this.originalParams.watchSlidesProgress = !0); }, setTranslate() { this.params.effect === 'coverflow' && this.coverflowEffect.setTranslate(); }, setTransition(e) { this.params.effect === 'coverflow' && this.coverflowEffect.setTransition(e); } },
  }, {
    name: 'thumbs',
    params: {
      thumbs: {
        swiper: null, multipleActiveThumbs: !0, autoScrollOffset: 0, slideThumbActiveClass: 'swiper-slide-thumb-active', thumbsContainerClass: 'swiper-container-thumbs',
      },
    },
    create() {
      n.extend(this, {
        thumbs: {
          swiper: null, init: be.init.bind(this), update: be.update.bind(this), onThumbClick: be.onThumbClick.bind(this),
        },
      });
    },
    on: {
      beforeInit() { const e = this.params.thumbs; e && e.swiper && (this.thumbs.init(), this.thumbs.update(!0)); }, slideChange() { this.thumbs.swiper && this.thumbs.update(); }, update() { this.thumbs.swiper && this.thumbs.update(); }, resize() { this.thumbs.swiper && this.thumbs.update(); }, observerUpdate() { this.thumbs.swiper && this.thumbs.update(); }, setTransition(e) { const t = this.thumbs.swiper; t && t.setTransition(e); }, beforeDestroy() { const e = this.thumbs.swiper; e && this.thumbs.swiperCreated && e && e.destroy(); },
    },
  }]; return void 0 === W.use && (W.use = W.Class.use, W.installModule = W.Class.installModule), W.use(we), W;
})));
// # sourceMappingURL=swiper.min.js.map
